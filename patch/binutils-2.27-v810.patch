diff -Naur binutils-2.27-pure/bfd/Makefile.am binutils-2.27/bfd/Makefile.am
--- binutils-2.27-pure/bfd/Makefile.am	2016-08-03 03:36:50.000000000 -0400
+++ binutils-2.27/bfd/Makefile.am	2022-02-10 13:50:25.334336700 -0500
@@ -162,6 +162,7 @@
 	cpu-tic80.lo \
 	cpu-tilegx.lo \
 	cpu-tilepro.lo \
+	cpu-v810.lo \
 	cpu-v850.lo \
 	cpu-v850_rh850.lo \
 	cpu-vax.lo \
@@ -249,6 +250,7 @@
 	cpu-tic80.c \
 	cpu-tilegx.c \
 	cpu-tilepro.c \
+	cpu-v810.c \
 	cpu-v850.c \
 	cpu-v850_rh850.c \
 	cpu-vax.c \
@@ -375,6 +377,7 @@
 	elf32-tic6x.lo \
 	elf32-tilegx.lo \
 	elf32-tilepro.lo \
+	elf32-v810.lo \
 	elf32-v850.lo \
 	elf32-vax.lo \
 	elf32-visium.lo \
@@ -567,6 +570,7 @@
 	elf32-tic6x.c \
 	elf32-tilegx.c \
 	elf32-tilepro.c \
+	elf32-v810.c \
 	elf32-v850.c \
 	elf32-vax.c \
 	elf32-visium.c \
diff -Naur binutils-2.27-pure/bfd/Makefile.in binutils-2.27/bfd/Makefile.in
--- binutils-2.27-pure/bfd/Makefile.in	2016-08-03 04:06:27.000000000 -0400
+++ binutils-2.27/bfd/Makefile.in	2022-02-10 13:50:25.354337900 -0500
@@ -494,6 +494,7 @@
 	cpu-tic80.lo \
 	cpu-tilegx.lo \
 	cpu-tilepro.lo \
+	cpu-v810.lo \
 	cpu-v850.lo \
 	cpu-v850_rh850.lo \
 	cpu-vax.lo \
@@ -581,6 +582,7 @@
 	cpu-tic80.c \
 	cpu-tilegx.c \
 	cpu-tilepro.c \
+	cpu-v810.c \
 	cpu-v850.c \
 	cpu-v850_rh850.c \
 	cpu-vax.c \
@@ -708,6 +710,7 @@
 	elf32-tic6x.lo \
 	elf32-tilegx.lo \
 	elf32-tilepro.lo \
+	elf32-v810.lo \
 	elf32-v850.lo \
 	elf32-vax.lo \
 	elf32-visium.lo \
@@ -900,6 +903,7 @@
 	elf32-tic6x.c \
 	elf32-tilegx.c \
 	elf32-tilepro.c \
+	elf32-v810.c \
 	elf32-v850.c \
 	elf32-vax.c \
 	elf32-visium.c \
@@ -1425,6 +1429,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-tic80.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-tilegx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-tilepro.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-v810.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-v850.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-v850_rh850.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-vax.Plo@am__quote@
@@ -1513,6 +1518,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-tic6x.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-tilegx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-tilepro.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-v810.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-v850.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-vax.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-visium.Plo@am__quote@
diff -Naur binutils-2.27-pure/bfd/archures.c binutils-2.27/bfd/archures.c
--- binutils-2.27-pure/bfd/archures.c	2016-08-03 03:36:50.000000000 -0400
+++ binutils-2.27/bfd/archures.c	2022-02-10 13:50:25.369338700 -0500
@@ -360,6 +360,8 @@
 .  bfd_arch_tic54x,    {* Texas Instruments TMS320C54X *}
 .  bfd_arch_tic6x,     {* Texas Instruments TMS320C6X *}
 .  bfd_arch_tic80,     {* TI TMS320c80 (MVP) *}
+.  bfd_arch_v810,      {* NEC V810 *}
+.#define bfd_mach_v810          1
 .  bfd_arch_v850,      {* NEC V850 *}
 .  bfd_arch_v850_rh850,{* NEC V850 (using RH850 ABI) *}
 .#define bfd_mach_v850          1
@@ -643,6 +645,7 @@
 extern const bfd_arch_info_type bfd_tic80_arch;
 extern const bfd_arch_info_type bfd_tilegx_arch;
 extern const bfd_arch_info_type bfd_tilepro_arch;
+extern const bfd_arch_info_type bfd_v810_arch;
 extern const bfd_arch_info_type bfd_v850_arch;
 extern const bfd_arch_info_type bfd_v850_rh850_arch;
 extern const bfd_arch_info_type bfd_vax_arch;
@@ -732,6 +735,7 @@
     &bfd_tic80_arch,
     &bfd_tilegx_arch,
     &bfd_tilepro_arch,
+    &bfd_v810_arch,
     &bfd_v850_arch,
     &bfd_v850_rh850_arch,
     &bfd_vax_arch,
diff -Naur binutils-2.27-pure/bfd/bfd-in2.h binutils-2.27/bfd/bfd-in2.h
--- binutils-2.27-pure/bfd/bfd-in2.h	2016-08-03 03:36:50.000000000 -0400
+++ binutils-2.27/bfd/bfd-in2.h	2022-02-10 13:50:25.384339600 -0500
@@ -2171,6 +2171,8 @@
   bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
   bfd_arch_tic6x,     /* Texas Instruments TMS320C6X */
   bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
+  bfd_arch_v810,      /* NEC V810 */
+#define bfd_mach_v810          1
   bfd_arch_v850,      /* NEC V850 */
   bfd_arch_v850_rh850,/* NEC V850 (using RH850 ABI) */
 #define bfd_mach_v850          1
@@ -4182,6 +4184,24 @@
   BFD_RELOC_NDS32_TLS_LE_15S2,
 
 /* This is a 9-bit reloc  */
+  BFD_RELOC_V810_9_PCREL,
+
+/* This is a 26-bit reloc  */
+  BFD_RELOC_V810_26_PCREL,
+
+/* This is a 16 bit offset from the short data area pointer.  */
+  BFD_RELOC_V810_SDA_16_16_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer.  */
+  BFD_RELOC_V810_ZDA_16_16_OFFSET,
+
+/* This is a 16 bit offset from the thread data area pointer.  */
+  BFD_RELOC_V810_TDA_16_16_OFFSET,
+
+/* Used to maintain alignment whilst relaxing.  */
+  BFD_RELOC_V810_ALIGN,
+
+/* This is a 9-bit reloc  */
   BFD_RELOC_V850_9_PCREL,
 
 /* This is a 22-bit reloc  */
diff -Naur binutils-2.27-pure/bfd/config.bfd binutils-2.27/bfd/config.bfd
--- binutils-2.27-pure/bfd/config.bfd	2016-08-03 03:36:50.000000000 -0400
+++ binutils-2.27/bfd/config.bfd	2022-02-10 13:50:25.400340500 -0500
@@ -129,6 +129,7 @@
 spu*)            targ_archs=bfd_spu_arch ;;
 tilegx*)	 targ_archs=bfd_tilegx_arch ;;
 tilepro*)	 targ_archs=bfd_tilepro_arch ;;
+v810*)		 targ_archs=bfd_v810_arch ;;
 v850*)		 targ_archs="bfd_v850_arch bfd_v850_rh850_arch" ;;
 visium*)	 targ_archs=bfd_visium_arch ;;
 x86_64*)	 targ_archs=bfd_i386_arch ;;
@@ -1673,6 +1674,10 @@
     targ_defvec=ft32_elf32_vec
     ;;
 
+  v810*-*-*)
+    targ_defvec=v810_elf32_vec
+    ;;
+
   v850*-*-*)
     targ_defvec=v850_elf32_vec
     targ_selvecs="v800_elf32_vec"
diff -Naur binutils-2.27-pure/bfd/configure binutils-2.27/bfd/configure
--- binutils-2.27-pure/bfd/configure	2022-02-10 13:45:24.539678900 -0500
+++ binutils-2.27/bfd/configure	2022-02-10 13:50:25.413341200 -0500
@@ -14513,6 +14513,7 @@
     tilegx_elf64_be_vec)	 tb="$tb elf64-tilegx.lo elfxx-tilegx.lo elf64.lo $elf" ; target_size=64 ;;
     tilegx_elf64_le_vec)	 tb="$tb elf64-tilegx.lo elfxx-tilegx.lo elf64.lo $elf" ; target_size=64 ;;
     tilepro_elf32_vec)		 tb="$tb elf32-tilepro.lo elf32.lo $elf" ;;
+    v810_elf32_vec)		 tb="$tb elf32-v810.lo elf32.lo $elf" ;;
     v800_elf32_vec)		 tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     v850_elf32_vec)		 tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     vax_aout_1knbsd_vec)	 tb="$tb vax1knetbsd.lo aout32.lo" ;;
diff -Naur binutils-2.27-pure/bfd/configure.ac binutils-2.27/bfd/configure.ac
--- binutils-2.27-pure/bfd/configure.ac	2016-08-03 03:36:50.000000000 -0400
+++ binutils-2.27/bfd/configure.ac	2022-02-10 13:50:25.429342100 -0500
@@ -688,6 +688,7 @@
     tilegx_elf64_be_vec)	 tb="$tb elf64-tilegx.lo elfxx-tilegx.lo elf64.lo $elf" ; target_size=64 ;;
     tilegx_elf64_le_vec)	 tb="$tb elf64-tilegx.lo elfxx-tilegx.lo elf64.lo $elf" ; target_size=64 ;;
     tilepro_elf32_vec)		 tb="$tb elf32-tilepro.lo elf32.lo $elf" ;;
+    v810_elf32_vec)		 tb="$tb elf32-v810.lo elf32.lo $elf" ;;
     v800_elf32_vec)		 tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     v850_elf32_vec)		 tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     vax_aout_1knbsd_vec)	 tb="$tb vax1knetbsd.lo aout32.lo" ;;
diff -Naur binutils-2.27-pure/bfd/cpu-v810.c binutils-2.27/bfd/cpu-v810.c
--- binutils-2.27-pure/bfd/cpu-v810.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/bfd/cpu-v810.c	2022-02-10 13:50:25.437342600 -0500
@@ -0,0 +1,31 @@
+/* BFD support for the NEC V810 processor
+   Copyright (C) 1996-2016 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "safe-ctype.h"
+
+#define N(number, print, default, next)  \
+{  32, 32, 8, bfd_arch_v810, number, "v810", print, 2, default, \
+   bfd_default_compatible, bfd_default_scan, bfd_arch_default_fill, next }
+
+const bfd_arch_info_type bfd_v810_arch =
+  N (bfd_mach_v810, "v810", TRUE, NULL);
diff -Naur binutils-2.27-pure/bfd/doc/archures.texi binutils-2.27/bfd/doc/archures.texi
--- binutils-2.27-pure/bfd/doc/archures.texi	2016-08-03 04:36:22.000000000 -0400
+++ binutils-2.27/bfd/doc/archures.texi	2022-02-10 13:50:25.449343300 -0500
@@ -327,6 +327,8 @@
   bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
   bfd_arch_tic6x,     /* Texas Instruments TMS320C6X */
   bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
+  bfd_arch_v810,      /* NEC V810 */
+#define bfd_mach_v810          1
   bfd_arch_v850,      /* NEC V850 */
   bfd_arch_v850_rh850,/* NEC V850 (using RH850 ABI) */
 #define bfd_mach_v850          1
diff -Naur binutils-2.27-pure/bfd/doc/bfd.info binutils-2.27/bfd/doc/bfd.info
--- binutils-2.27-pure/bfd/doc/bfd.info	2016-08-03 04:36:22.000000000 -0400
+++ binutils-2.27/bfd/doc/bfd.info	2022-02-10 13:50:25.467344300 -0500
@@ -5063,6 +5063,24 @@
  -- : BFD_RELOC_NDS32_TLS_LE_15S2
      For TLS.
 
+ -- : BFD_RELOC_V810_9_PCREL
+     This is a 9-bit reloc
+
+ -- : BFD_RELOC_V810_26_PCREL
+     This is a 26-bit reloc
+
+ -- : BFD_RELOC_V810_SDA_16_16_OFFSET
+     This is a 16 bit offset from the short data area pointer.
+
+ -- : BFD_RELOC_V810_ZDA_16_16_OFFSET
+     This is a 16 bit offset from the zero data area pointer.
+
+ -- : BFD_RELOC_V810_TDA_16_16_OFFSET
+     This is a 16 bit offset from the thread data area pointer.
+
+ -- : BFD_RELOC_V810_ALIGN
+     Used to maintain alignment whilst relaxing.
+
  -- : BFD_RELOC_V850_9_PCREL
      This is a 9-bit reloc
 
@@ -8301,6 +8319,8 @@
        bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
        bfd_arch_tic6x,     /* Texas Instruments TMS320C6X */
        bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
+       bfd_arch_v810,      /* NEC V810 */
+     #define bfd_mach_v810          1
        bfd_arch_v850,      /* NEC V850 */
        bfd_arch_v850_rh850,/* NEC V850 (using RH850 ABI) */
      #define bfd_mach_v850          1
diff -Naur binutils-2.27-pure/bfd/doc/reloc.texi binutils-2.27/bfd/doc/reloc.texi
--- binutils-2.27-pure/bfd/doc/reloc.texi	2016-08-03 04:36:22.000000000 -0400
+++ binutils-2.27/bfd/doc/reloc.texi	2022-02-10 13:50:25.484345300 -0500
@@ -2061,6 +2061,24 @@
 @deffnx {} BFD_RELOC_NDS32_TLS_LE_15S2
 For TLS.
 @end deffn
+@deffn {} BFD_RELOC_V810_9_PCREL
+This is a 9-bit reloc
+@end deffn
+@deffn {} BFD_RELOC_V810_26_PCREL
+This is a 26-bit reloc
+@end deffn
+@deffn {} BFD_RELOC_V810_SDA_16_16_OFFSET
+This is a 16 bit offset from the short data area pointer.
+@end deffn
+@deffn {} BFD_RELOC_V810_ZDA_16_16_OFFSET
+This is a 16 bit offset from the zero data area pointer.
+@end deffn
+@deffn {} BFD_RELOC_V810_TDA_16_16_OFFSET
+This is a 16 bit offset from the thread data area pointer.
+@end deffn
+@deffn {} BFD_RELOC_V810_ALIGN
+Used to maintain alignment whilst relaxing.
+@end deffn
 @deffn {} BFD_RELOC_V850_9_PCREL
 This is a 9-bit reloc
 @end deffn
diff -Naur binutils-2.27-pure/bfd/elf32-v810.c binutils-2.27/bfd/elf32-v810.c
--- binutils-2.27-pure/bfd/elf32-v810.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/bfd/elf32-v810.c	2022-02-10 13:50:25.498346100 -0500
@@ -0,0 +1,2096 @@
+/* V810-specific support for 32-bit ELF
+   Copyright (C) 1996-2016 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* XXX FIXME: This code is littered with 32bit int, 16bit short, 8bit char
+   dependencies.  As is the gas & simulator code for the v810.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/v810.h"
+#include "libiberty.h"
+
+/* Sign-extend a 26-bit number.  */
+#define SEXT26(x)       ((((x) & 0x3ffffff) ^ 0x2000000) - 0x2000000)
+
+static reloc_howto_type v810_elf_howto_table[];
+
+/* Look through the relocs for a section during the first phase, and
+   allocate space in the global offset table or procedure linkage
+   table.  */
+
+static bfd_boolean
+v810_elf_check_relocs (bfd *abfd,
+                       struct bfd_link_info *info,
+                       asection *sec,
+                       const Elf_Internal_Rela *relocs)
+{
+  bfd_boolean ret = TRUE;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+  unsigned int r_type;
+  int other = 0;
+  const char *common = NULL;
+
+  if (bfd_link_relocatable (info))
+    return TRUE;
+
+#ifdef DEBUG
+  _bfd_error_handler ("v810_elf_check_relocs called for section %A in %B",
+                      sec, abfd);
+#endif
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      unsigned long r_symndx;
+      struct elf_link_hash_entry *h;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx < symtab_hdr->sh_info)
+        h = NULL;
+      else
+        {
+          h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+          while (h->root.type == bfd_link_hash_indirect
+                 || h->root.type == bfd_link_hash_warning)
+            h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+          /* PR15323, ref flags aren't set for references in the same
+             object.  */
+          h->root.non_ir_ref = 1;
+        }
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      switch (r_type)
+        {
+        default:
+          break;
+
+        /* This relocation describes the C++ object vtable hierarchy.
+           Reconstruct it for later use during GC.  */
+        case R_V810_GNU_VTINHERIT:
+          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+            return FALSE;
+          break;
+
+        /* This relocation describes which C++ vtable entries
+           are actually used.  Record for later use during GC.  */
+        case R_V810_GNU_VTENTRY:
+          BFD_ASSERT (h != NULL);
+          if (h != NULL
+              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+            return FALSE;
+          break;
+
+        case R_V810_SDA_16_16_OFFSET:
+          other = V810_OTHER_SDA;
+          common = ".scommon";
+          goto small_data_common;
+
+        case R_V810_ZDA_16_16_OFFSET:
+          other = V810_OTHER_ZDA;
+          common = ".zcommon";
+          goto small_data_common;
+
+        case R_V810_TDA_16_16_OFFSET:
+          other = V810_OTHER_TDA;
+          common = ".tcommon";
+          /* fall through */
+
+#define V810_OTHER_MASK (V810_OTHER_TDA | V810_OTHER_SDA | V810_OTHER_ZDA)
+
+        small_data_common:
+          if (h)
+            {
+              /* Flag which type of relocation was used.  */
+              h->other |= other;
+              if ((h->other & V810_OTHER_MASK) != (other & V810_OTHER_MASK)
+                  && (h->other & V810_OTHER_ERROR) == 0)
+                {
+                  const char * msg;
+                  static char  buff[200]; /* XXX */
+
+                  switch (h->other & V810_OTHER_MASK)
+                    {
+                    default:
+                      msg = _("Variable `%s' cannot occupy in multiple small data regions");
+                      break;
+                    case V810_OTHER_SDA | V810_OTHER_ZDA | V810_OTHER_TDA:
+                      msg = _("Variable `%s' can only be in one of the small, zero, and thread data regions");
+                      break;
+                    case V810_OTHER_SDA | V810_OTHER_ZDA:
+                      msg = _("Variable `%s' cannot be in both small and zero data regions simultaneously");
+                      break;
+                    case V810_OTHER_SDA | V810_OTHER_TDA:
+                      msg = _("Variable `%s' cannot be in both small and thread data regions simultaneously");
+                      break;
+                    case V810_OTHER_ZDA | V810_OTHER_TDA:
+                      msg = _("Variable `%s' cannot be in both zero and thread data regions simultaneously");
+                      break;
+                    }
+
+                  sprintf (buff, msg, h->root.root.string);
+                  info->callbacks->warning (info, buff, h->root.root.string,
+                                            abfd, h->root.u.def.section,
+                                            (bfd_vma) 0);
+
+                  bfd_set_error (bfd_error_bad_value);
+                  h->other |= V810_OTHER_ERROR;
+                  ret = FALSE;
+                }
+            }
+
+          if (h && h->root.type == bfd_link_hash_common
+              && h->root.u.c.p
+              && !strcmp (bfd_get_section_name (abfd, h->root.u.c.p->section), "COMMON"))
+            {
+              asection * section;
+
+              section = h->root.u.c.p->section = bfd_make_section_old_way (abfd, common);
+              section->flags |= SEC_IS_COMMON;
+            }
+
+#ifdef DEBUG
+          fprintf (stderr, "v810_elf_check_relocs, found %s relocation for %s%s\n",
+                   v810_elf_howto_table[ (int)r_type ].name,
+                   (h && h->root.root.string) ? h->root.root.string : "<unknown>",
+                   (h->root.type == bfd_link_hash_common) ? ", symbol is common" : "");
+#endif
+          break;
+        }
+    }
+
+  return ret;
+}
+
+/* In the old version, when an entry was checked out from the table,
+   it was deleted.  This produced an error if the entry was needed
+   more than once, as the second attempted retry failed.
+
+   In the current version, the entry is not deleted, instead we set
+   the field 'found' to TRUE.  If a second lookup matches the same
+   entry, then we know that the hi16s reloc has already been updated
+   and does not need to be updated a second time.
+
+   TODO - TOFIX: If it is possible that we need to restore 2 different
+   addresses from the same table entry, where the first generates an
+   overflow, whilst the second do not, then this code will fail.  */
+
+typedef struct hi16s_location
+{
+  bfd_vma                 addend;
+  bfd_byte *              address;
+  unsigned long           counter;
+  bfd_boolean             found;
+  struct hi16s_location * next;
+}
+hi16s_location;
+
+static hi16s_location * previous_hi16s;
+static hi16s_location * free_hi16s;
+static unsigned long    hi16s_counter;
+
+static void
+remember_hi16s_reloc (bfd *abfd, bfd_vma addend, bfd_byte *address)
+{
+  hi16s_location * entry = NULL;
+  bfd_size_type amt = sizeof (* free_hi16s);
+
+  /* Find a free structure.  */
+  if (free_hi16s == NULL)
+    free_hi16s = bfd_zalloc (abfd, amt);
+
+  entry      = free_hi16s;
+  free_hi16s = free_hi16s->next;
+
+  entry->addend  = addend;
+  entry->address = address;
+  entry->counter = hi16s_counter ++;
+  entry->found   = FALSE;
+  entry->next    = previous_hi16s;
+  previous_hi16s = entry;
+
+  /* Cope with wrap around of our counter.  */
+  if (hi16s_counter == 0)
+    {
+      /* XXX: Assume that all counter entries differ only in their low 16 bits.  */
+      for (entry = previous_hi16s; entry != NULL; entry = entry->next)
+        entry->counter &= 0xffff;
+
+      hi16s_counter = 0x10000;
+    }
+}
+
+static bfd_byte *
+find_remembered_hi16s_reloc (bfd_vma addend, bfd_boolean *already_found)
+{
+  hi16s_location *match = NULL;
+  hi16s_location *entry;
+  bfd_byte *addr;
+
+  /* Search the table.  Record the most recent entry that matches.  */
+  for (entry = previous_hi16s; entry; entry = entry->next)
+    {
+      if (entry->addend == addend
+          && (match == NULL || match->counter < entry->counter))
+        {
+          match    = entry;
+        }
+    }
+
+  if (match == NULL)
+    return NULL;
+
+  /* Extract the address.  */
+  addr = match->address;
+
+  /* Remember if this entry has already been used before.  */
+  if (already_found)
+    * already_found = match->found;
+
+  /* Note that this entry has now been used.  */
+  match->found = TRUE;
+
+  return addr;
+}
+
+/* Calculate the final operand value for a R_V810_LO16 or
+   R_V810_LO16_SPLIT_OFFSET.  *INSN is the current operand value and
+   ADDEND is the sum of the relocation symbol and offset.  Store the
+   operand value in *INSN and return true on success.
+
+   The assembler has already done some of this: If the value stored in
+   the instruction has its 15th bit set, (counting from zero) then the
+   assembler will have added 1 to the value stored in the associated
+   HI16S reloc.  So for example, these relocations:
+
+       movhi hi( fred ), r0, r1
+       movea lo( fred ), r1, r1
+
+   will store 0 in the value fields for the MOVHI and MOVEA instructions
+   and addend will be the address of fred, but for these instructions:
+
+       movhi hi( fred + 0x123456 ), r0, r1
+       movea lo( fred + 0x123456 ), r1, r1
+
+   the value stored in the MOVHI instruction will be 0x12 and the value
+   stored in the MOVEA instruction will be 0x3456.  If however the
+   instructions were:
+
+       movhi hi( fred + 0x10ffff ), r0, r1
+       movea lo( fred + 0x10ffff ), r1, r1
+
+   then the value stored in the MOVHI instruction would be 0x11 (not
+   0x10) and the value stored in the MOVEA instruction would be 0xffff.
+   Thus (assuming for the moment that the addend is 0), at run time the
+   MOVHI instruction loads 0x110000 into r1, then the MOVEA instruction
+   adds 0xffffffff (sign extension!) producing 0x10ffff.  Similarly if
+   the instructions were:
+
+       movhi hi( fred - 1 ), r0, r1
+       movea lo( fred - 1 ), r1, r1
+
+   then 0 is stored in the MOVHI instruction and -1 is stored in the
+   MOVEA instruction.
+
+   Overflow can occur if the addition of the value stored in the
+   instruction plus the addend sets the 15th bit when before it was clear.
+   This is because the 15th bit will be sign extended into the high part,
+   thus reducing its value by one, but since the 15th bit was originally
+   clear, the assembler will not have added 1 to the previous HI16S reloc
+   to compensate for this effect.  For example:
+
+      movhi hi( fred + 0x123456 ), r0, r1
+      movea lo( fred + 0x123456 ), r1, r1
+
+   The value stored in HI16S reloc is 0x12, the value stored in the LO16
+   reloc is 0x3456.  If we assume that the address of fred is 0x00007000
+   then the relocations become:
+
+     HI16S: 0x0012 + (0x00007000 >> 16)    = 0x12
+     LO16:  0x3456 + (0x00007000 & 0xffff) = 0xa456
+
+   but when the instructions are executed, the MOVEA instruction's value
+   is signed extended, so the sum becomes:
+
+        0x00120000
+      + 0xffffa456
+      ------------
+        0x0011a456    but 'fred + 0x123456' = 0x0012a456
+
+   Note that if the 15th bit was set in the value stored in the LO16
+   reloc, then we do not have to do anything:
+
+      movhi hi( fred + 0x10ffff ), r0, r1
+      movea lo( fred + 0x10ffff ), r1, r1
+
+      HI16S:  0x0011 + (0x00007000 >> 16)    = 0x11
+      LO16:   0xffff + (0x00007000 & 0xffff) = 0x6fff
+
+        0x00110000
+      + 0x00006fff
+      ------------
+        0x00116fff  = fred + 0x10ffff = 0x7000 + 0x10ffff
+
+   Overflow can also occur if the computation carries into the 16th bit
+   and it also results in the 15th bit having the same value as the 15th
+   bit of the original value.   What happens is that the HI16S reloc
+   will have already examined the 15th bit of the original value and
+   added 1 to the high part if the bit is set.  This compensates for the
+   sign extension of 15th bit of the result of the computation.  But now
+   there is a carry into the 16th bit, and this has not been allowed for.
+
+   So, for example if fred is at address 0xf000:
+
+     movhi hi( fred + 0xffff ), r0, r1    [bit 15 of the offset is set]
+     movea lo( fred + 0xffff ), r1, r1
+
+     HI16S: 0x0001 + (0x0000f000 >> 16)    = 0x0001
+     LO16:  0xffff + (0x0000f000 & 0xffff) = 0xefff   (carry into bit 16 is lost)
+
+       0x00010000
+     + 0xffffefff
+     ------------
+       0x0000efff   but 'fred + 0xffff' = 0x0001efff
+
+   Similarly, if the 15th bit remains clear, but overflow occurs into
+   the 16th bit then (assuming the address of fred is 0xf000):
+
+     movhi hi( fred + 0x7000 ), r0, r1    [bit 15 of the offset is clear]
+     movea lo( fred + 0x7000 ), r1, r1
+
+     HI16S: 0x0000 + (0x0000f000 >> 16)    = 0x0000
+     LO16:  0x7000 + (0x0000f000 & 0xffff) = 0x6fff  (carry into bit 16 is lost)
+
+       0x00000000
+     + 0x00006fff
+     ------------
+       0x00006fff   but 'fred + 0x7000' = 0x00016fff
+
+   Note - there is no need to change anything if a carry occurs, and the
+   15th bit changes its value from being set to being clear, as the HI16S
+   reloc will have already added in 1 to the high part for us:
+
+     movhi hi( fred + 0xffff ), r0, r1     [bit 15 of the offset is set]
+     movea lo( fred + 0xffff ), r1, r1
+
+     HI16S: 0x0001 + (0x00007000 >> 16)
+     LO16:  0xffff + (0x00007000 & 0xffff) = 0x6fff  (carry into bit 16 is lost)
+
+       0x00010000
+     + 0x00006fff   (bit 15 not set, so the top half is zero)
+     ------------
+       0x00016fff   which is right (assuming that fred is at 0x7000)
+
+   but if the 15th bit goes from being clear to being set, then we must
+   once again handle overflow:
+
+     movhi hi( fred + 0x7000 ), r0, r1     [bit 15 of the offset is clear]
+     movea lo( fred + 0x7000 ), r1, r1
+
+     HI16S: 0x0000 + (0x0000ffff >> 16)
+     LO16:  0x7000 + (0x0000ffff & 0xffff) = 0x6fff  (carry into bit 16)
+
+       0x00000000
+     + 0x00006fff   (bit 15 not set, so the top half is zero)
+     ------------
+       0x00006fff   which is wrong (assuming that fred is at 0xffff).  */
+
+static bfd_boolean
+v810_elf_perform_lo16_relocation (bfd *abfd, unsigned long *insn,
+                                  unsigned long addend)
+{
+#define BIT15_SET(x) ((x) & 0x8000)
+#define OVERFLOWS(a,i) ((((a) & 0xffff) + (i)) > 0xffff)
+
+  if ((BIT15_SET (*insn + addend) && ! BIT15_SET (addend))
+      || (OVERFLOWS (addend, *insn)
+          && ((! BIT15_SET (*insn)) || (BIT15_SET (addend)))))
+    {
+      bfd_boolean already_updated;
+      bfd_byte *hi16s_address = find_remembered_hi16s_reloc
+        (addend, & already_updated);
+
+      /* Amend the matching HI16_S relocation.  */
+      if (hi16s_address != NULL)
+        {
+          if (! already_updated)
+            {
+              unsigned long hi_insn = bfd_get_16 (abfd, hi16s_address);
+              hi_insn += 1;
+              bfd_put_16 (abfd, hi_insn, hi16s_address);
+            }
+        }
+      else
+        {
+          (*_bfd_error_handler) (_("FAILED to find previous HI16 reloc"));
+          return FALSE;
+        }
+    }
+#undef OVERFLOWS
+#undef BIT15_SET
+
+  /* Do not complain if value has top bit set, as this has been
+     anticipated.  */
+  *insn = (*insn + addend) & 0xffff;
+  return TRUE;
+}
+
+/* FIXME:  The code here probably ought to be removed and the code in reloc.c
+   allowed to do its stuff instead.  At least for most of the relocs, anyway.  */
+
+static bfd_reloc_status_type
+v810_elf_perform_relocation (bfd *abfd,
+                             unsigned int r_type,
+                             bfd_vma addend,
+                             bfd_byte *address)
+{
+  unsigned long insn;
+  bfd_signed_vma saddend = (bfd_signed_vma) addend;
+
+  switch (r_type)
+    {
+    default:
+#ifdef DEBUG
+      fprintf (stderr, "%B: reloc number %d not recognised\n", abfd, r_type);
+#endif
+      return bfd_reloc_notsupported;
+
+    case R_V810_ABS32:
+      bfd_put_32 (abfd, addend, address);
+      return bfd_reloc_ok;
+
+    case R_V810_26_PCREL:
+      if (saddend > 0x1ffffff || saddend < -0x2000000)
+        return bfd_reloc_overflow;
+
+      if ((addend % 2) != 0)
+        return bfd_reloc_dangerous;
+
+      insn  = bfd_get_32 (abfd, address);
+      insn &= ~0xfffe03ff;
+      insn |= (((addend & 0xfffe) << 16) | ((addend & 0x3ff0000) >> 16));
+      bfd_put_32 (abfd, (bfd_vma) insn, address);
+      return bfd_reloc_ok;
+
+    case R_V810_9_PCREL:
+      if (saddend > 0xff || saddend < -0x100)
+        return bfd_reloc_overflow;
+
+      if ((addend % 2) != 0)
+        return bfd_reloc_dangerous;
+
+      insn  = bfd_get_16 (abfd, address);
+      insn &= ~ 0x01ff;
+      insn |= (addend & 0x1ff);
+      break;
+
+    case R_V810_HI16:
+      addend += (bfd_get_16 (abfd, address) << 16);
+      addend = (addend >> 16);
+      insn = addend;
+      break;
+
+    case R_V810_HI16_S:
+      /* Remember where this relocation took place.  */
+      remember_hi16s_reloc (abfd, addend, address);
+
+      addend += (bfd_get_16 (abfd, address) << 16);
+      addend = (addend >> 16) + ((addend & 0x8000) != 0);
+
+      /* This relocation cannot overflow.  */
+      if (addend > 0xffff)
+        addend = 0;
+
+      insn = addend;
+      break;
+
+    case R_V810_LO16:
+      insn = bfd_get_16 (abfd, address);
+      if (! v810_elf_perform_lo16_relocation (abfd, &insn, addend))
+        return bfd_reloc_overflow;
+      break;
+
+    case R_V810_8:
+      addend += (char) bfd_get_8 (abfd, address);
+
+      saddend = (bfd_signed_vma) addend;
+
+      if (saddend > 0x7f || saddend < -0x80)
+        return bfd_reloc_overflow;
+
+      bfd_put_8 (abfd, addend, address);
+      return bfd_reloc_ok;
+
+    case R_V810_16:
+    case R_V810_SDA_16_16_OFFSET:
+    case R_V810_ZDA_16_16_OFFSET:
+    case R_V810_TDA_16_16_OFFSET:
+      addend += bfd_get_16 (abfd, address);
+
+      saddend = (bfd_signed_vma) addend;
+
+      if (saddend > 0x7fff || saddend < -0x8000)
+        return bfd_reloc_overflow;
+
+      insn = addend;
+      break;
+
+    case R_V810_GNU_VTINHERIT:
+    case R_V810_GNU_VTENTRY:
+      return bfd_reloc_ok;
+
+    }
+
+  bfd_put_16 (abfd, (bfd_vma) insn, address);
+  return bfd_reloc_ok;
+}
+
+/* Insert the addend into the instruction.  */
+
+static bfd_reloc_status_type
+v810_elf_reloc (bfd *abfd ATTRIBUTE_UNUSED,
+                arelent *reloc,
+                asymbol *symbol,
+                void * data ATTRIBUTE_UNUSED,
+                asection *isection,
+                bfd *obfd,
+                char **err ATTRIBUTE_UNUSED)
+{
+  long relocation;
+
+  /* If there is an output BFD,
+     and the symbol is not a section name (which is only defined at final link time),
+     and either we are not putting the addend into the instruction
+      or the addend is zero, so there is nothing to add into the instruction
+     then just fixup the address and return.  */
+  if (obfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (! reloc->howto->partial_inplace
+          || reloc->addend == 0))
+    {
+      reloc->address += isection->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  /* Catch relocs involving undefined symbols.  */
+  if (bfd_is_und_section (symbol->section)
+      && (symbol->flags & BSF_WEAK) == 0
+      && obfd == NULL)
+    return bfd_reloc_undefined;
+
+  /* We handle final linking of some relocs ourselves.  */
+
+  /* Is the address of the relocation really within the section?  */
+  if (reloc->address > bfd_get_section_limit (abfd, isection))
+    return bfd_reloc_outofrange;
+
+  /* Work out which section the relocation is targeted at and the
+     initial relocation command value.  */
+
+  if (reloc->howto->pc_relative)
+    return bfd_reloc_ok;
+
+  /* Get symbol value.  (Common symbols are special.)  */
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+
+  /* Convert input-section-relative symbol value to absolute + addend.  */
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+  relocation += reloc->addend;
+
+  reloc->addend = relocation;
+  return bfd_reloc_ok;
+}
+
+/* This function is used for relocs which are only used
+   for relaxing, which the linker should otherwise ignore.  */
+
+static bfd_reloc_status_type
+v810_elf_ignore_reloc (bfd *abfd ATTRIBUTE_UNUSED,
+                       arelent *reloc_entry,
+                       asymbol *symbol ATTRIBUTE_UNUSED,
+                       void * data ATTRIBUTE_UNUSED,
+                       asection *input_section,
+                       bfd *output_bfd,
+                       char **error_message ATTRIBUTE_UNUSED)
+{
+  if (output_bfd != NULL)
+    reloc_entry->address += input_section->output_offset;
+
+  return bfd_reloc_ok;
+}
+/* Note: It is REQUIRED that the 'type' value of each entry
+   in this array match the index of the entry in the array.
+   SeeAlso: RELOC_NUBMER in include/elf/v810.h  */
+static reloc_howto_type v810_elf_howto_table[] =
+{
+  /* This reloc does nothing.  */
+  HOWTO (R_V810_NONE,                   /* Type.  */
+         0,                             /* Rightshift.  */
+         3,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         0,                             /* Bitsize.  */
+         FALSE,                         /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_dont,        /* Complain_on_overflow.  */
+         bfd_elf_generic_reloc,         /* Special_function.  */
+         "R_V810_NONE",                 /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0,                             /* Src_mask.  */
+         0,                             /* Dst_mask.  */
+         FALSE),                        /* PCrel_offset.  */
+
+  /* A PC relative 9 bit branch.  */
+  HOWTO (R_V810_9_PCREL,                /* Type.  */
+         0,                             /* Rightshift.  */
+         1,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         9,                             /* Bitsize.  */
+         TRUE,                          /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_bitfield,    /* Complain_on_overflow.  */
+         v810_elf_reloc,                /* Special_function.  */
+         "R_V810_9_PCREL",              /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0x00ffffff,                    /* Src_mask.  */
+         0x00ffffff,                    /* Dst_mask.  */
+         TRUE),                         /* PCrel_offset.  */
+
+  /* A PC relative 26 bit branch.  */
+  HOWTO (R_V810_26_PCREL,               /* Type.  */
+         0,                             /* Rightshift.  */
+         2,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         26,                            /* Bitsize.  */
+         TRUE,                          /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_signed,      /* Complain_on_overflow.  */
+         v810_elf_reloc,                /* Special_function.  */
+         "R_V810_26_PCREL",             /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0x03ffffff,                    /* Src_mask.  */
+         0x03ffffff,                    /* Dst_mask.  */
+         TRUE),                         /* PCrel_offset.  */
+
+  /* High 16 bits of symbol value.  */
+  HOWTO (R_V810_HI16_S,                 /* Type.  */
+         0,                             /* Rightshift.  */
+         1,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         16,                            /* Bitsize.  */
+         FALSE,                         /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_dont,        /* Complain_on_overflow.  */
+         v810_elf_reloc,                /* Special_function.  */
+         "R_V810_HI16_S",               /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0xffff,                        /* Src_mask.  */
+         0xffff,                        /* Dst_mask.  */
+         FALSE),                        /* PCrel_offset.  */
+
+  /* High 16 bits of symbol value.  */
+  HOWTO (R_V810_HI16,                   /* Type.  */
+         0,                             /* Rightshift.  */
+         1,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         16,                            /* Bitsize.  */
+         FALSE,                         /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_dont,        /* Complain_on_overflow.  */
+         v810_elf_reloc,                /* Special_function.  */
+         "R_V810_HI16",                 /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0xffff,                        /* Src_mask.  */
+         0xffff,                        /* Dst_mask.  */
+         FALSE),                        /* PCrel_offset.  */
+
+  /* Low 16 bits of symbol value.  */
+  HOWTO (R_V810_LO16,                   /* Type.  */
+         0,                             /* Rightshift.  */
+         1,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         16,                            /* Bitsize.  */
+         FALSE,                         /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_dont,        /* Complain_on_overflow.  */
+         v810_elf_reloc,                /* Special_function.  */
+         "R_V810_LO16",                 /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0xffff,                        /* Src_mask.  */
+         0xffff,                        /* Dst_mask.  */
+         FALSE),                        /* PCrel_offset.  */
+
+  /* Simple 32bit reloc.  */
+  HOWTO (R_V810_ABS32,                  /* Type.  */
+         0,                             /* Rightshift.  */
+         2,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         32,                            /* Bitsize.  */
+         FALSE,                         /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_dont,        /* Complain_on_overflow.  */
+         v810_elf_reloc,                /* Special_function.  */
+         "R_V810_ABS32",                /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0xffffffff,                    /* Src_mask.  */
+         0xffffffff,                    /* Dst_mask.  */
+         FALSE),                        /* PCrel_offset.  */
+
+  /* Simple 16bit reloc.  */
+  HOWTO (R_V810_16,                     /* Type.  */
+         0,                             /* Rightshift.  */
+         1,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         16,                            /* Bitsize.  */
+         FALSE,                         /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_dont,        /* Complain_on_overflow.  */
+         bfd_elf_generic_reloc,         /* Special_function.  */
+         "R_V810_16",                   /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0xffff,                        /* Src_mask.  */
+         0xffff,                        /* Dst_mask.  */
+         FALSE),                        /* PCrel_offset.  */
+
+  /* Simple 8bit reloc.  */
+  HOWTO (R_V810_8,                      /* Type.  */
+         0,                             /* Rightshift.  */
+         0,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         8,                             /* Bitsize.  */
+         FALSE,                         /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_dont,        /* Complain_on_overflow.  */
+         bfd_elf_generic_reloc,         /* Special_function.  */
+         "R_V810_8",                    /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0xff,                          /* Src_mask.  */
+         0xff,                          /* Dst_mask.  */
+         FALSE),                        /* PCrel_offset.  */
+
+  /* 16 bit offset from the short data area pointer.  */
+  HOWTO (R_V810_SDA_16_16_OFFSET,       /* Type.  */
+         0,                             /* Rightshift.  */
+         1,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         16,                            /* Bitsize.  */
+         FALSE,                         /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_dont,        /* Complain_on_overflow.  */
+         v810_elf_reloc,                /* Special_function.  */
+         "R_V810_SDA_16_16_OFFSET",     /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0xffff,                        /* Src_mask.  */
+         0xffff,                        /* Dst_mask.  */
+         FALSE),                        /* PCrel_offset.  */
+
+  /* 16 bit offset from the zero data area pointer.  */
+  HOWTO (R_V810_ZDA_16_16_OFFSET,       /* Type.  */
+         0,                             /* Rightshift.  */
+         1,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         16,                            /* Bitsize.  */
+         FALSE,                         /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_dont,        /* Complain_on_overflow.  */
+         v810_elf_reloc,                /* Special_function.  */
+         "R_V810_ZDA_16_16_OFFSET",     /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0xffff,                        /* Src_mask.  */
+         0xffff,                        /* Dst_mask.  */
+         FALSE),                        /* PCrel_offset.  */
+
+  /* 16 bit offset from the short data area pointer.  */
+  HOWTO (R_V810_TDA_16_16_OFFSET,       /* Type.  */
+         0,                             /* Rightshift.  */
+         1,                             /* Size (0 = byte, 1 = short, 2 = long).  */
+         16,                            /* Bitsize.  */
+         FALSE,                         /* PC_relative.  */
+         0,                             /* Bitpos.  */
+         complain_overflow_dont,        /* Complain_on_overflow.  */
+         v810_elf_reloc,                /* Special_function.  */
+         "R_V810_TDA_16_16_OFFSET",     /* Name.  */
+         FALSE,                         /* Partial_inplace.  */
+         0xffff,                        /* Src_mask.  */
+         0xffff,                        /* Dst_mask.  */
+         FALSE),                        /* PCrel_offset.  */
+
+  /* GNU extension to record C++ vtable hierarchy */
+  HOWTO (R_V810_GNU_VTINHERIT, /* Type.  */
+         0,                     /* Rightshift.  */
+         2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
+         0,                     /* Bitsize.  */
+         FALSE,                 /* PC_relative.  */
+         0,                     /* Bitpos.  */
+         complain_overflow_dont, /* Complain_on_overflow.  */
+         NULL,                  /* Special_function.  */
+         "R_V810_GNU_VTINHERIT", /* Name.  */
+         FALSE,                 /* Partial_inplace.  */
+         0,                     /* Src_mask.  */
+         0,                     /* Dst_mask.  */
+         FALSE),                /* PCrel_offset.  */
+
+  /* GNU extension to record C++ vtable member usage.  */
+  HOWTO (R_V810_GNU_VTENTRY,     /* Type.  */
+         0,                     /* Rightshift.  */
+         2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
+         0,                     /* Bitsize.  */
+         FALSE,                 /* PC_relative.  */
+         0,                     /* Bitpos.  */
+         complain_overflow_dont, /* Complain_on_overflow.  */
+         _bfd_elf_rel_vtable_reloc_fn,  /* Special_function.  */
+         "R_V810_GNU_VTENTRY",   /* Name.  */
+         FALSE,                 /* Partial_inplace.  */
+         0,                     /* Src_mask.  */
+         0,                     /* Dst_mask.  */
+         FALSE),                /* PCrel_offset.  */
+
+  HOWTO (R_V810_ALIGN,        /* Type.  */
+         0,                     /* Rightshift.  */
+         1,                     /* Size (0 = byte, 1 = short, 2 = long).  */
+         0,                     /* Bitsize.  */
+         FALSE,                 /* PC_relative.  */
+         0,                     /* Bitpos.  */
+         complain_overflow_unsigned, /* Complain_on_overflow.  */
+         v810_elf_ignore_reloc, /* Special_function.  */
+         "R_V810_ALIGN",        /* Name.  */
+         FALSE,                 /* Partial_inplace.  */
+         0,                     /* Src_mask.  */
+         0,                     /* Dst_mask.  */
+         TRUE),                 /* PCrel_offset.  */
+};
+
+/* Map BFD reloc types to V810 ELF reloc types.  */
+
+struct v810_elf_reloc_map
+{
+  /* BFD_RELOC_V810_CALLT_16_16_OFFSET is 258, which will not fix in an
+     unsigned char.  */
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned int elf_reloc_val;
+};
+
+static const struct v810_elf_reloc_map v810_elf_reloc_map[] =
+{
+  { BFD_RELOC_NONE,                        R_V810_NONE                   },
+  { BFD_RELOC_V810_9_PCREL,                R_V810_9_PCREL                },
+  { BFD_RELOC_V810_26_PCREL,               R_V810_26_PCREL               },
+  { BFD_RELOC_HI16_S,                      R_V810_HI16_S                 },
+  { BFD_RELOC_HI16,                        R_V810_HI16                   },
+  { BFD_RELOC_LO16,                        R_V810_LO16                   },
+  { BFD_RELOC_32,                          R_V810_ABS32                  },
+  { BFD_RELOC_16,                          R_V810_16                     },
+  { BFD_RELOC_8,                           R_V810_8                      },
+  { BFD_RELOC_V810_SDA_16_16_OFFSET,       R_V810_SDA_16_16_OFFSET       },
+  { BFD_RELOC_V810_ZDA_16_16_OFFSET,       R_V810_ZDA_16_16_OFFSET       },
+  { BFD_RELOC_V810_TDA_16_16_OFFSET,       R_V810_TDA_16_16_OFFSET       },
+  { BFD_RELOC_VTABLE_INHERIT,              R_V810_GNU_VTINHERIT          },
+  { BFD_RELOC_VTABLE_ENTRY,                R_V810_GNU_VTENTRY            },
+  { BFD_RELOC_V810_ALIGN,                  R_V810_ALIGN                  },
+};
+
+/* Map a bfd relocation into the appropriate howto structure.  */
+
+static reloc_howto_type *
+v810_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+                            bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  for (i = ARRAY_SIZE (v810_elf_reloc_map); i --;)
+    if (v810_elf_reloc_map[i].bfd_reloc_val == code)
+      {
+        unsigned int elf_reloc_val = v810_elf_reloc_map[i].elf_reloc_val;
+
+        BFD_ASSERT (v810_elf_howto_table[elf_reloc_val].type == elf_reloc_val);
+
+        return v810_elf_howto_table + elf_reloc_val;
+      }
+
+  return NULL;
+}
+
+static reloc_howto_type *
+v810_elf_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+                            const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < sizeof (v810_elf_howto_table) / sizeof (v810_elf_howto_table[0]);
+       i++)
+    if (v810_elf_howto_table[i].name != NULL
+        && strcasecmp (v810_elf_howto_table[i].name, r_name) == 0)
+      return &v810_elf_howto_table[i];
+
+  return NULL;
+}
+
+/* Set the howto pointer for an V810 ELF reloc.  */
+
+static void
+v810_elf_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
+                            arelent *cache_ptr,
+                            Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  if (r_type >= (unsigned int) R_V810_max)
+    {
+      _bfd_error_handler (_("%B: invalid V810 reloc number: %d"), abfd, r_type);
+      r_type = 0;
+    }
+  cache_ptr->howto = &v810_elf_howto_table[r_type];
+}
+
+/* Set the howto pointer for a V810 ELF reloc (type RELA).  */
+
+static void
+v810_elf_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
+                             arelent * cache_ptr,
+                             Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  if (r_type >= (unsigned int) R_V810_max)
+    {
+      _bfd_error_handler (_("%B: invalid V810 reloc number: %d"), abfd, r_type);
+      r_type = 0;
+    }
+  cache_ptr->howto = &v810_elf_howto_table[r_type];
+}
+
+static bfd_boolean
+v810_elf_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED, const char *name)
+{
+  return (   (name[0] == '.' && (name[1] == 'L' || name[1] == '.'))
+          || (name[0] == '_' &&  name[1] == '.' && name[2] == 'L' && name[3] == '_'));
+}
+
+static bfd_boolean
+v810_elf_is_target_special_symbol (bfd *abfd, asymbol *sym)
+{
+  return v810_elf_is_local_label_name (abfd, sym->name);
+}
+
+/* We overload some of the bfd_reloc error codes for own purposes.  */
+#define bfd_reloc_gp_not_found          bfd_reloc_other
+#define bfd_reloc_tp_not_found          bfd_reloc_continue
+
+/* Perform a relocation as part of a final link.  */
+
+static bfd_reloc_status_type
+v810_elf_final_link_relocate (reloc_howto_type *howto,
+                              bfd *input_bfd,
+                              bfd *output_bfd ATTRIBUTE_UNUSED,
+                              asection *input_section,
+                              bfd_byte *contents,
+                              bfd_vma offset,
+                              bfd_vma value,
+                              bfd_vma addend,
+                              struct bfd_link_info *info,
+                              asection *sym_sec,
+                              int is_local ATTRIBUTE_UNUSED)
+{
+  unsigned int r_type = howto->type;
+  bfd_byte *hit_data = contents + offset;
+
+  /* Adjust the value according to the relocation.  */
+  switch (r_type)
+    {
+    case R_V810_9_PCREL:
+      value -= (input_section->output_section->vma
+		+ input_section->output_offset);
+      value -= offset;
+      break;
+
+    case R_V810_26_PCREL:
+      value -= (input_section->output_section->vma
+		+ input_section->output_offset
+		+ offset);
+
+      /* If the sign extension will corrupt the value then we have overflowed.  */
+      if (((value & 0xfe000000) != 0x0) && ((value & 0xfe000000) != 0xfe000000))
+	return bfd_reloc_overflow;
+
+      /* Only the bottom 26 bits of the PC are valid.  */
+      value = SEXT26 (value);
+      break;
+
+    case R_V810_HI16_S:
+    case R_V810_HI16:
+    case R_V810_LO16:
+    case R_V810_16:
+    case R_V810_ABS32:
+    case R_V810_8:
+      break;
+
+    case R_V810_ZDA_16_16_OFFSET:
+      if (sym_sec == NULL)
+	return bfd_reloc_undefined;
+
+      value -= sym_sec->output_section->vma;
+      break;
+
+    case R_V810_SDA_16_16_OFFSET:
+      {
+	bfd_vma                      gp;
+	struct bfd_link_hash_entry * h;
+
+	if (sym_sec == NULL)
+	  return bfd_reloc_undefined;
+
+	/* Get the value of __gp.  */
+	h = bfd_link_hash_lookup (info->hash, "__gp", FALSE, FALSE, TRUE);
+	if (h == NULL
+	    || h->type != bfd_link_hash_defined)
+	  return bfd_reloc_gp_not_found;
+
+	gp = (h->u.def.value
+	      + h->u.def.section->output_section->vma
+	      + h->u.def.section->output_offset);
+
+	value -= gp;
+      }
+    break;
+
+    case R_V810_TDA_16_16_OFFSET:
+      {
+	bfd_vma                      tp;
+	struct bfd_link_hash_entry * h;
+
+	/* Get the value of __tp.  */
+	h = bfd_link_hash_lookup (info->hash, "__tp", FALSE, FALSE, TRUE);
+	if (h == NULL
+	    || h->type != bfd_link_hash_defined)
+	  return bfd_reloc_tp_not_found;
+
+	tp = (h->u.def.value
+	      + h->u.def.section->output_section->vma
+	      + h->u.def.section->output_offset);
+
+	value -= tp;
+      }
+    break;
+
+    case R_V810_NONE:
+    case R_V810_GNU_VTINHERIT:
+    case R_V810_GNU_VTENTRY:
+    case R_V810_ALIGN:
+      return bfd_reloc_ok;
+
+    default:
+#ifdef DEBUG
+      fprintf (stderr, "%B: reloc number %d not recognised\n", input_bfd, r_type);
+#endif
+      return bfd_reloc_notsupported;
+    }
+
+  /* Perform the relocation.  */
+  return v810_elf_perform_relocation (input_bfd, r_type, value + addend, hit_data);
+}
+
+/* Relocate an V810 ELF section.  */
+
+static bfd_boolean
+v810_elf_relocate_section (bfd *output_bfd,
+                           struct bfd_link_info *info,
+                           bfd *input_bfd,
+                           asection *input_section,
+                           bfd_byte *contents,
+                           Elf_Internal_Rela *relocs,
+                           Elf_Internal_Sym *local_syms,
+                           asection **local_sections)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+
+  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+
+  /* Reset the list of remembered HI16S relocs to empty.  */
+  free_hi16s     = previous_hi16s;
+  previous_hi16s = NULL;
+  hi16s_counter  = 0;
+
+  rel    = relocs;
+  relend = relocs + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      unsigned int r_type;
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      struct elf_link_hash_entry *h;
+      bfd_vma relocation;
+      bfd_reloc_status_type r;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      r_type   = ELF32_R_TYPE (rel->r_info);
+
+      if (r_type == R_V810_GNU_VTENTRY
+          || r_type == R_V810_GNU_VTINHERIT)
+        continue;
+
+      howto = v810_elf_howto_table + r_type;
+
+      BFD_ASSERT (r_type == howto->type);
+
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+      if (r_symndx < symtab_hdr->sh_info)
+        {
+          sym = local_syms + r_symndx;
+          sec = local_sections[r_symndx];
+          relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+        }
+      else
+        {
+          bfd_boolean unresolved_reloc, warned, ignored;
+
+          /* Note - this check is delayed until now as it is possible and
+             valid to have a file without any symbols but with relocs that
+             can be processed.  */
+          if (sym_hashes == NULL)
+            {
+              info->callbacks->warning
+                (info, "no hash table available",
+                 NULL, input_bfd, input_section, (bfd_vma) 0);
+
+              return FALSE;
+            }
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned, ignored);
+        }
+
+      if (sec != NULL && discarded_section (sec))
+        RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+                                         rel, 1, relend, howto, 0, contents);
+
+      if (bfd_link_relocatable (info))
+        continue;
+
+      /* FIXME: We should use the addend, but the COFF relocations don't.  */
+      r = v810_elf_final_link_relocate (howto, input_bfd, output_bfd,
+                                        input_section,
+                                        contents, rel->r_offset,
+                                        relocation, rel->r_addend,
+                                        info, sec, h == NULL);
+
+      if (r != bfd_reloc_ok)
+        {
+          const char * name;
+          const char * msg = NULL;
+
+          if (h != NULL)
+            name = h->root.root.string;
+          else
+            {
+              name = (bfd_elf_string_from_elf_section
+                      (input_bfd, symtab_hdr->sh_link, sym->st_name));
+              if (name == NULL || *name == '\0')
+                name = bfd_section_name (input_bfd, sec);
+            }
+
+	  switch ((int) r)
+	    {
+	    case bfd_reloc_overflow:
+	      (*info->callbacks->reloc_overflow)
+		(info, (h ? &h->root : NULL), name, howto->name,
+		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
+	      break;
+
+	    case bfd_reloc_undefined:
+	      (*info->callbacks->undefined_symbol)
+		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
+	      break;
+
+	    case bfd_reloc_outofrange:
+	      msg = _("internal error: out of range error");
+	      goto common_error;
+
+	    case bfd_reloc_notsupported:
+	      msg = _("internal error: unsupported relocation error");
+	      goto common_error;
+
+	    case bfd_reloc_dangerous:
+	      msg = _("internal error: dangerous relocation");
+	      goto common_error;
+
+	    case bfd_reloc_gp_not_found:
+	      msg = _("could not locate special linker symbol __gp");
+	      goto common_error;
+
+	    case bfd_reloc_tp_not_found:
+	      msg = _("could not locate special linker symbol __tp");
+	      goto common_error;
+
+	    default:
+	      msg = _("internal error: unknown error");
+	      /* fall through */
+
+	    common_error:
+	      (*info->callbacks->warning) (info, msg, name, input_bfd,
+					   input_section, rel->r_offset);
+	      break;
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+static asection *
+v810_elf_gc_mark_hook (asection *sec,
+                       struct bfd_link_info *info,
+                       Elf_Internal_Rela *rel,
+                       struct elf_link_hash_entry *h,
+                       Elf_Internal_Sym *sym)
+{
+  if (h != NULL)
+    switch (ELF32_R_TYPE (rel->r_info))
+      {
+      case R_V810_GNU_VTINHERIT:
+      case R_V810_GNU_VTENTRY:
+        return NULL;
+      }
+
+  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
+}
+
+/* Set the right machine number.  */
+
+static bfd_boolean
+v810_elf_object_p (bfd *abfd)
+{
+  switch (elf_elfheader (abfd)->e_flags & EF_V810_ARCH)
+    {
+    default:
+    case E_V810_ARCH:
+      bfd_default_set_arch_mach (abfd, bfd_arch_v810, bfd_mach_v810);
+      break;
+    }
+  return TRUE;
+}
+
+/* Store the machine number in the flags field.  */
+
+static void
+v810_elf_final_write_processing (bfd *abfd,
+                                 bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  unsigned long val;
+
+  switch (bfd_get_mach (abfd))
+    {
+    default:
+    case bfd_mach_v810:   val = E_V810_ARCH; break;
+    }
+
+  elf_elfheader (abfd)->e_flags &=~ EF_V810_ARCH;
+  elf_elfheader (abfd)->e_flags |= val;
+}
+
+/* Function to keep V810 specific file flags.  */
+
+static bfd_boolean
+v810_elf_set_private_flags (bfd *abfd, flagword flags)
+{
+  BFD_ASSERT (!elf_flags_init (abfd)
+              || elf_elfheader (abfd)->e_flags == flags);
+
+  elf_elfheader (abfd)->e_flags = flags;
+  elf_flags_init (abfd) = TRUE;
+  return TRUE;
+}
+
+/* Merge backend specific data from an object file
+   to the output object file when linking.  */
+
+static bfd_boolean
+v810_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
+{
+  flagword out_flags;
+  flagword in_flags;
+  bfd_boolean result = TRUE;
+
+  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return TRUE;
+
+  in_flags = elf_elfheader (ibfd)->e_flags;
+  out_flags = elf_elfheader (obfd)->e_flags;
+
+  if (! elf_flags_init (obfd))
+    {
+      /* If the input is the default architecture then do not
+         bother setting the flags for the output architecture,
+         instead allow future merges to do this.  If no future
+         merges ever set these flags then they will retain their
+         unitialised values, which surprise surprise, correspond
+         to the default values.  */
+      if (bfd_get_arch_info (ibfd)->the_default)
+        return TRUE;
+
+      elf_flags_init (obfd) = TRUE;
+      elf_elfheader (obfd)->e_flags = in_flags;
+
+      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
+          && bfd_get_arch_info (obfd)->the_default)
+	result &= bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
+
+      return result;
+    }
+
+  /* Check flag compatibility.  */
+  if (in_flags == out_flags)
+    return result;
+
+  if ((in_flags & EF_V810_ARCH) != (out_flags & EF_V810_ARCH)
+      && (in_flags & EF_V810_ARCH) != E_V810_ARCH)
+    {
+      _bfd_error_handler (_("%B: Architecture mismatch with previous modules"),
+                          ibfd);
+    }
+
+  return result;
+}
+
+/* Display the flags field.  */
+
+static bfd_boolean
+v810_elf_print_private_bfd_data (bfd *abfd, void * ptr)
+{
+  FILE * file = (FILE *) ptr;
+
+  BFD_ASSERT (abfd != NULL && ptr != NULL);
+
+  _bfd_elf_print_private_bfd_data (abfd, ptr);
+
+  /* xgettext:c-format.  */
+  fprintf (file, _("private flags = %lx: "), elf_elfheader (abfd)->e_flags);
+
+  switch (elf_elfheader (abfd)->e_flags & EF_V810_ARCH)
+    {
+    default:
+    case E_V810_ARCH: fprintf (file, _("v810 architecture")); break;
+    }
+
+  fputc ('\n', file);
+
+  return TRUE;
+}
+
+/* V810 ELF uses four common sections.  One is the usual one, and the
+   others are for (small) objects in one of the special data areas:
+   small, thread and zero.  All the objects are kept together, and then
+   referenced via the gp register, the ep register or the r0 register
+   respectively, which yields smaller, faster assembler code.  This
+   approach is copied from elf32-mips.c.  */
+
+static asection  v810_elf_scom_section;
+static asymbol   v810_elf_scom_symbol;
+static asymbol * v810_elf_scom_symbol_ptr;
+static asection  v810_elf_tcom_section;
+static asymbol   v810_elf_tcom_symbol;
+static asymbol * v810_elf_tcom_symbol_ptr;
+static asection  v810_elf_zcom_section;
+static asymbol   v810_elf_zcom_symbol;
+static asymbol * v810_elf_zcom_symbol_ptr;
+
+/* Given a BFD section, try to locate the
+   corresponding ELF section index.  */
+
+static bfd_boolean
+v810_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
+                                   asection *sec,
+                                   int *retval)
+{
+  if (strcmp (bfd_get_section_name (abfd, sec), ".scommon") == 0)
+    *retval = SHN_V810_SCOMMON;
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".tcommon") == 0)
+    *retval = SHN_V810_TCOMMON;
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".zcommon") == 0)
+    *retval = SHN_V810_ZCOMMON;
+  else
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Handle the special V810 section numbers that a symbol may use.  */
+
+static void
+v810_elf_symbol_processing (bfd *abfd, asymbol *asym)
+{
+  elf_symbol_type * elfsym = (elf_symbol_type *) asym;
+  unsigned int indx;
+
+  indx = elfsym->internal_elf_sym.st_shndx;
+
+  /* If the section index is an "ordinary" index, then it may
+     refer to a v810 specific section created by the assembler.
+     Check the section's type and change the index it matches.
+
+     FIXME: Should we alter the st_shndx field as well ?  */
+
+  if (indx < elf_numsections (abfd))
+    switch (elf_elfsections (abfd)[indx]->sh_type)
+      {
+      case SHT_V810_SCOMMON:
+        indx = SHN_V810_SCOMMON;
+        break;
+
+      case SHT_V810_TCOMMON:
+        indx = SHN_V810_TCOMMON;
+        break;
+
+      case SHT_V810_ZCOMMON:
+        indx = SHN_V810_ZCOMMON;
+        break;
+
+      default:
+        break;
+      }
+
+  switch (indx)
+    {
+    case SHN_V810_SCOMMON:
+      if (v810_elf_scom_section.name == NULL)
+        {
+          /* Initialize the small common section.  */
+          v810_elf_scom_section.name           = ".scommon";
+          v810_elf_scom_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+          v810_elf_scom_section.output_section = & v810_elf_scom_section;
+          v810_elf_scom_section.symbol         = & v810_elf_scom_symbol;
+          v810_elf_scom_section.symbol_ptr_ptr = & v810_elf_scom_symbol_ptr;
+          v810_elf_scom_symbol.name            = ".scommon";
+          v810_elf_scom_symbol.flags           = BSF_SECTION_SYM;
+          v810_elf_scom_symbol.section         = & v810_elf_scom_section;
+          v810_elf_scom_symbol_ptr             = & v810_elf_scom_symbol;
+        }
+      asym->section = & v810_elf_scom_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_V810_TCOMMON:
+      if (v810_elf_tcom_section.name == NULL)
+        {
+          /* Initialize the tcommon section.  */
+          v810_elf_tcom_section.name           = ".tcommon";
+          v810_elf_tcom_section.flags          = SEC_IS_COMMON;
+          v810_elf_tcom_section.output_section = & v810_elf_tcom_section;
+          v810_elf_tcom_section.symbol         = & v810_elf_tcom_symbol;
+          v810_elf_tcom_section.symbol_ptr_ptr = & v810_elf_tcom_symbol_ptr;
+          v810_elf_tcom_symbol.name            = ".tcommon";
+          v810_elf_tcom_symbol.flags           = BSF_SECTION_SYM;
+          v810_elf_tcom_symbol.section         = & v810_elf_tcom_section;
+          v810_elf_tcom_symbol_ptr             = & v810_elf_tcom_symbol;
+        }
+      asym->section = & v810_elf_tcom_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_V810_ZCOMMON:
+      if (v810_elf_zcom_section.name == NULL)
+        {
+          /* Initialize the zcommon section.  */
+          v810_elf_zcom_section.name           = ".zcommon";
+          v810_elf_zcom_section.flags          = SEC_IS_COMMON;
+          v810_elf_zcom_section.output_section = & v810_elf_zcom_section;
+          v810_elf_zcom_section.symbol         = & v810_elf_zcom_symbol;
+          v810_elf_zcom_section.symbol_ptr_ptr = & v810_elf_zcom_symbol_ptr;
+          v810_elf_zcom_symbol.name            = ".zcommon";
+          v810_elf_zcom_symbol.flags           = BSF_SECTION_SYM;
+          v810_elf_zcom_symbol.section         = & v810_elf_zcom_section;
+          v810_elf_zcom_symbol_ptr             = & v810_elf_zcom_symbol;
+        }
+      asym->section = & v810_elf_zcom_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+    }
+}
+
+/* Hook called by the linker routine which adds symbols from an object
+   file.  We must handle the special v810 section numbers here.  */
+
+static bfd_boolean
+v810_elf_add_symbol_hook (bfd *abfd,
+                          struct bfd_link_info *info ATTRIBUTE_UNUSED,
+                          Elf_Internal_Sym *sym,
+                          const char **namep ATTRIBUTE_UNUSED,
+                          flagword *flagsp ATTRIBUTE_UNUSED,
+                          asection **secp,
+                          bfd_vma *valp)
+{
+  unsigned int indx = sym->st_shndx;
+
+  /* If the section index is an "ordinary" index, then it may
+     refer to a v810 specific section created by the assembler.
+     Check the section's type and change the index it matches.
+
+     FIXME: Should we alter the st_shndx field as well ?  */
+
+  if (indx < elf_numsections (abfd))
+    switch (elf_elfsections (abfd)[indx]->sh_type)
+      {
+      case SHT_V810_SCOMMON:
+        indx = SHN_V810_SCOMMON;
+        break;
+
+      case SHT_V810_TCOMMON:
+        indx = SHN_V810_TCOMMON;
+        break;
+
+      case SHT_V810_ZCOMMON:
+        indx = SHN_V810_ZCOMMON;
+        break;
+
+      default:
+        break;
+      }
+
+  switch (indx)
+    {
+    case SHN_V810_SCOMMON:
+      *secp = bfd_make_section_old_way (abfd, ".scommon");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+
+    case SHN_V810_TCOMMON:
+      *secp = bfd_make_section_old_way (abfd, ".tcommon");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+
+    case SHN_V810_ZCOMMON:
+      *secp = bfd_make_section_old_way (abfd, ".zcommon");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+    }
+
+  return TRUE;
+}
+
+static int
+v810_elf_link_output_symbol_hook (struct bfd_link_info *info ATTRIBUTE_UNUSED,
+                                  const char *name ATTRIBUTE_UNUSED,
+                                  Elf_Internal_Sym *sym,
+                                  asection *input_sec,
+                                  struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
+{
+  /* If we see a common symbol, which implies a relocatable link, then
+     if a symbol was in a special common section in an input file, mark
+     it as a special common in the output file.  */
+
+  if (sym->st_shndx == SHN_COMMON)
+    {
+      if (strcmp (input_sec->name, ".scommon") == 0)
+        sym->st_shndx = SHN_V810_SCOMMON;
+      else if (strcmp (input_sec->name, ".tcommon") == 0)
+        sym->st_shndx = SHN_V810_TCOMMON;
+      else if (strcmp (input_sec->name, ".zcommon") == 0)
+        sym->st_shndx = SHN_V810_ZCOMMON;
+    }
+
+  /* The price we pay for using h->other unused bits as flags in the
+     linker is cleaning up after ourselves.  */
+
+  sym->st_other &= ~(V810_OTHER_SDA | V810_OTHER_ZDA | V810_OTHER_TDA
+                     | V810_OTHER_ERROR);
+
+  return 1;
+}
+
+static bfd_boolean
+v810_elf_section_from_shdr (bfd *abfd,
+                            Elf_Internal_Shdr *hdr,
+                            const char *name,
+                            int shindex)
+{
+  /* There ought to be a place to keep ELF backend specific flags, but
+     at the moment there isn't one.  We just keep track of the
+     sections by their name, instead.  */
+
+  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
+    return FALSE;
+
+  switch (hdr->sh_type)
+    {
+    case SHT_V810_SCOMMON:
+    case SHT_V810_TCOMMON:
+    case SHT_V810_ZCOMMON:
+      if (! bfd_set_section_flags (abfd, hdr->bfd_section,
+                                   (bfd_get_section_flags (abfd,
+                                                           hdr->bfd_section)
+                                    | SEC_IS_COMMON)))
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Set the correct type for a V810 ELF section.  We do this
+   by the section name, which is a hack, but ought to work.  */
+
+static bfd_boolean
+v810_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
+                        Elf_Internal_Shdr *hdr,
+                        asection *sec)
+{
+  const char * name;
+
+  name = bfd_get_section_name (abfd, sec);
+
+  if (strcmp (name, ".scommon") == 0)
+    hdr->sh_type = SHT_V810_SCOMMON;
+  else if (strcmp (name, ".tcommon") == 0)
+    hdr->sh_type = SHT_V810_TCOMMON;
+  else if (strcmp (name, ".zcommon") == 0)
+    hdr->sh_type = SHT_V810_ZCOMMON;
+
+  return TRUE;
+}
+
+/* Delete some bytes from a section while relaxing.  */
+
+static bfd_boolean
+v810_elf_relax_delete_bytes (bfd *abfd,
+                             asection *sec,
+                             bfd_vma addr,
+                             bfd_vma toaddr,
+                             int count)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf32_External_Sym *extsyms;
+  Elf32_External_Sym *esym;
+  Elf32_External_Sym *esymend;
+  int sym_index;
+  unsigned int sec_shndx;
+  bfd_byte *contents;
+  Elf_Internal_Rela *irel;
+  Elf_Internal_Rela *irelend;
+  struct elf_link_hash_entry *sym_hash;
+  Elf_External_Sym_Shndx *shndx;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
+
+  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
+
+  contents = elf_section_data (sec)->this_hdr.contents;
+
+  /* The deletion must stop at the next ALIGN reloc for an alignment
+     power larger than the number of bytes we are deleting.  */
+
+  /* Actually delete the bytes.  */
+#if (DEBUG_RELAX & 2)
+  fprintf (stderr, "relax_delete: contents: sec: %s  %p .. %p %x\n",
+           sec->name, addr, toaddr, count );
+#endif
+  memmove (contents + addr, contents + addr + count,
+           toaddr - addr - count);
+  memset (contents + toaddr-count, 0, count);
+
+  /* Adjust all the relocs.  */
+  irel = elf_section_data (sec)->relocs;
+  irelend = irel + sec->reloc_count;
+  if (elf_symtab_shndx_list (abfd))
+    {
+      Elf_Internal_Shdr *shndx_hdr;
+
+      shndx_hdr = & elf_symtab_shndx_list (abfd)->hdr;
+      shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
+    }
+  else
+    {
+      shndx = NULL;
+    }
+
+  for (; irel < irelend; irel++)
+    {
+      bfd_vma raddr, paddr, symval;
+      Elf_Internal_Sym isym;
+
+      /* Get the new reloc address.  */
+      raddr = irel->r_offset;
+      if ((raddr >= (addr + count) && raddr < toaddr))
+        irel->r_offset -= count;
+
+      if (raddr >= addr && raddr < addr + count)
+        {
+          irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
+                                       (int) R_V810_NONE);
+          continue;
+        }
+
+      if (ELF32_R_TYPE (irel->r_info) == (int) R_V810_ALIGN)
+        continue;
+
+      bfd_elf32_swap_symbol_in (abfd,
+                                extsyms + ELF32_R_SYM (irel->r_info),
+                                shndx ? shndx + ELF32_R_SYM (irel->r_info) : NULL,
+                                & isym);
+
+      if (isym.st_shndx != sec_shndx)
+        continue;
+
+      /* Get the value of the symbol referred to by the reloc.  */
+      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
+        {
+          symval = isym.st_value;
+#if (DEBUG_RELAX & 2)
+          {
+            char * name = bfd_elf_string_from_elf_section
+                           (abfd, symtab_hdr->sh_link, isym.st_name);
+            fprintf (stderr,
+               "relax_delete: local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
+               sec->name, name, isym.st_name,
+               sec->output_section->vma, sec->output_offset,
+               isym.st_value, irel->r_addend);
+          }
+#endif
+        }
+      else
+        {
+          unsigned long indx;
+          struct elf_link_hash_entry * h;
+
+          /* An external symbol.  */
+          indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
+
+          h = elf_sym_hashes (abfd) [indx];
+          BFD_ASSERT (h != NULL);
+
+          symval = h->root.u.def.value;
+#if (DEBUG_RELAX & 2)
+          fprintf (stderr,
+                   "relax_delete: defined: sec: %s, name: %s, value: %x + %x + %x addend %x\n",
+                   sec->name, h->root.root.string, h->root.u.def.value,
+                   sec->output_section->vma, sec->output_offset, irel->r_addend);
+#endif
+        }
+
+      paddr = symval + irel->r_addend;
+
+      if ( (symval >= addr + count && symval < toaddr)
+          && (paddr < addr + count || paddr >= toaddr))
+        irel->r_addend += count;
+      else if (    (symval < addr + count || symval >= toaddr)
+                && (paddr >= addr + count && paddr < toaddr))
+        irel->r_addend -= count;
+    }
+
+  /* Adjust the local symbols defined in this section.  */
+  esym = extsyms;
+  esymend = esym + symtab_hdr->sh_info;
+
+  for (; esym < esymend; esym++, shndx = (shndx ? shndx + 1 : NULL))
+    {
+      Elf_Internal_Sym isym;
+
+      bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
+
+      if (isym.st_shndx == sec_shndx
+          && isym.st_value >= addr + count
+          && isym.st_value < toaddr)
+        {
+          isym.st_value -= count;
+
+          if (isym.st_value + isym.st_size >= toaddr)
+            isym.st_size += count;
+
+          bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
+        }
+      else if (isym.st_shndx == sec_shndx
+               && isym.st_value < addr + count)
+        {
+          if (isym.st_value+isym.st_size >= addr + count
+              && isym.st_value+isym.st_size < toaddr)
+            isym.st_size -= count;
+
+          if (isym.st_value >= addr
+              && isym.st_value <  addr + count)
+            isym.st_value = addr;
+
+          bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
+        }
+    }
+
+  /* Now adjust the global symbols defined in this section.  */
+  esym = extsyms + symtab_hdr->sh_info;
+  esymend = extsyms + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
+
+  for (sym_index = 0; esym < esymend; esym ++, sym_index ++)
+    {
+      Elf_Internal_Sym isym;
+
+      bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
+      sym_hash = elf_sym_hashes (abfd) [sym_index];
+
+      if (isym.st_shndx == sec_shndx
+          && ((sym_hash)->root.type == bfd_link_hash_defined
+              || (sym_hash)->root.type == bfd_link_hash_defweak)
+          && (sym_hash)->root.u.def.section == sec
+          && (sym_hash)->root.u.def.value >= addr + count
+          && (sym_hash)->root.u.def.value < toaddr)
+        {
+          if ((sym_hash)->root.u.def.value + isym.st_size >= toaddr)
+            {
+              isym.st_size += count;
+              bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
+            }
+
+          (sym_hash)->root.u.def.value -= count;
+        }
+      else if (isym.st_shndx == sec_shndx
+               && ((sym_hash)->root.type == bfd_link_hash_defined
+                   || (sym_hash)->root.type == bfd_link_hash_defweak)
+               && (sym_hash)->root.u.def.section == sec
+               && (sym_hash)->root.u.def.value < addr + count)
+        {
+          if ((sym_hash)->root.u.def.value+isym.st_size >= addr + count
+              && (sym_hash)->root.u.def.value+isym.st_size < toaddr)
+            isym.st_size -= count;
+
+          if ((sym_hash)->root.u.def.value >= addr
+              && (sym_hash)->root.u.def.value < addr + count)
+            (sym_hash)->root.u.def.value = addr;
+
+          bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
+        }
+
+      if (shndx)
+        ++ shndx;
+    }
+
+  return TRUE;
+}
+
+#define NOP_OPCODE      (0x0000)
+
+static bfd_boolean
+v810_elf_relax_section (bfd *abfd,
+                        asection *sec,
+                        struct bfd_link_info *link_info,
+                        bfd_boolean *again)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Rela *internal_relocs;
+  Elf_Internal_Rela *irel;
+  Elf_Internal_Rela *irelend;
+  Elf_Internal_Rela *irelalign = NULL;
+  Elf_Internal_Sym *isymbuf = NULL;
+  bfd_byte *contents = NULL;
+  bfd_vma addr = 0;
+  bfd_vma toaddr;
+  int align_pad_size = 0;
+  bfd_boolean result = TRUE;
+
+  *again = FALSE;
+
+  if (bfd_link_relocatable (link_info)
+      || (sec->flags & SEC_RELOC) == 0
+      || sec->reloc_count == 0)
+    return TRUE;
+
+  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
+
+  internal_relocs = (_bfd_elf_link_read_relocs
+                     (abfd, sec, NULL, NULL, link_info->keep_memory));
+  if (internal_relocs == NULL)
+    goto error_return;
+
+  irelend = internal_relocs + sec->reloc_count;
+
+  while (addr < sec->size)
+    {
+      toaddr = sec->size;
+
+      for (irel = internal_relocs; irel < irelend; irel ++)
+        if (ELF32_R_TYPE (irel->r_info) == (int) R_V810_ALIGN
+            && irel->r_offset > addr
+            && irel->r_offset < toaddr)
+          toaddr = irel->r_offset;
+
+#ifdef DEBUG_RELAX
+      fprintf (stderr, "relax region 0x%x to 0x%x align pad %d\n",
+               addr, toaddr, align_pad_size);
+#endif
+      if (irelalign)
+        {
+          bfd_vma alignto;
+          bfd_vma alignmoveto;
+
+          alignmoveto = BFD_ALIGN (addr - align_pad_size, 1 << irelalign->r_addend);
+          alignto = BFD_ALIGN (addr, 1 << irelalign->r_addend);
+
+          if (alignmoveto < alignto)
+            {
+              bfd_vma i;
+
+              align_pad_size = alignto - alignmoveto;
+#ifdef DEBUG_RELAX
+              fprintf (stderr, "relax move region 0x%x to 0x%x delete size 0x%x\n",
+                       alignmoveto, toaddr, align_pad_size);
+#endif
+              if (!v810_elf_relax_delete_bytes (abfd, sec, alignmoveto,
+                                                toaddr, align_pad_size))
+                goto error_return;
+
+              for (i  = BFD_ALIGN (toaddr - align_pad_size, 1);
+                   (i + 1) < toaddr; i += 2)
+                bfd_put_16 (abfd, NOP_OPCODE, contents + i);
+
+              addr = alignmoveto;
+            }
+          else
+            align_pad_size = 0;
+        }
+
+      irelalign = NULL;
+      for (irel = internal_relocs; irel < irelend; irel++)
+        {
+          if (ELF32_R_TYPE (irel->r_info) == (int) R_V810_ALIGN
+              && irel->r_offset == toaddr)
+            {
+              irel->r_offset -= align_pad_size;
+
+              if (irelalign == NULL || irelalign->r_addend > irel->r_addend)
+                irelalign = irel;
+            }
+        }
+
+      addr = toaddr;
+    }
+
+  if (!irelalign)
+    {
+#ifdef DEBUG_RELAX
+      fprintf (stderr, "relax pad %d shorten %d -> %d\n",
+               align_pad_size,
+               sec->size,
+               sec->size - align_pad_size);
+#endif
+      sec->size -= align_pad_size;
+    }
+
+ finish:
+  if (internal_relocs != NULL
+      && elf_section_data (sec)->relocs != internal_relocs)
+    free (internal_relocs);
+
+  if (contents != NULL
+      && elf_section_data (sec)->this_hdr.contents != (unsigned char *) contents)
+    free (contents);
+
+  if (isymbuf != NULL
+      && symtab_hdr->contents != (bfd_byte *) isymbuf)
+    free (isymbuf);
+
+  return result;
+
+ error_return:
+  result = FALSE;
+  goto finish;
+}
+
+static const struct bfd_elf_special_section v810_elf_special_sections[] =
+{
+  { STRING_COMMA_LEN (".rosdata"),        -2, SHT_PROGBITS,     (SHF_ALLOC
+                                                                 + SHF_V810_GPREL) },
+  { STRING_COMMA_LEN (".rozdata"),        -2, SHT_PROGBITS,     (SHF_ALLOC
+                                                                 + SHF_V810_R0REL) },
+  { STRING_COMMA_LEN (".sbss"),           -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
+                                                                 + SHF_V810_GPREL) },
+  { STRING_COMMA_LEN (".scommon"),        -2, SHT_V810_SCOMMON, (SHF_ALLOC + SHF_WRITE
+                                                                 + SHF_V810_GPREL) },
+  { STRING_COMMA_LEN (".sdata"),          -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
+                                                                 + SHF_V810_GPREL) },
+  { STRING_COMMA_LEN (".tbss"),           -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
+                                                                 + SHF_V810_TPREL) },
+  { STRING_COMMA_LEN (".tcommon"),        -2, SHT_V810_TCOMMON, (SHF_ALLOC + SHF_WRITE
+                                                                 + SHF_V810_TPREL) },
+  { STRING_COMMA_LEN (".tdata"),          -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
+                                                                 + SHF_V810_TPREL) },
+  { STRING_COMMA_LEN (".zbss"),           -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
+                                                                 + SHF_V810_R0REL) },
+  { STRING_COMMA_LEN (".zcommon"),        -2, SHT_V810_ZCOMMON, (SHF_ALLOC + SHF_WRITE
+                                                                 + SHF_V810_R0REL) },
+  { STRING_COMMA_LEN (".zdata"),          -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
+                                                                 + SHF_V810_R0REL) },
+  { NULL,                     0,           0, 0,                0 }
+};
+
+// #define TARGET_LITTLE_SYM                       bfd_elf32_v810_vec
+#define TARGET_LITTLE_SYM                       v810_elf32_vec
+#define TARGET_LITTLE_NAME                      "elf32-v810"
+#define ELF_ARCH                                bfd_arch_v810
+#define ELF_MACHINE_CODE                        EM_PCFX_V810
+#define ELF_MAXPAGESIZE                         0x1000
+
+#define elf_info_to_howto                       v810_elf_info_to_howto_rela
+#define elf_info_to_howto_rel                   v810_elf_info_to_howto_rel
+
+#define elf_backend_check_relocs                v810_elf_check_relocs
+#define elf_backend_relocate_section            v810_elf_relocate_section
+#define elf_backend_object_p                    v810_elf_object_p
+#define elf_backend_final_write_processing      v810_elf_final_write_processing
+#define elf_backend_section_from_bfd_section    v810_elf_section_from_bfd_section
+#define elf_backend_symbol_processing           v810_elf_symbol_processing
+#define elf_backend_add_symbol_hook             v810_elf_add_symbol_hook
+#define elf_backend_link_output_symbol_hook     v810_elf_link_output_symbol_hook
+#define elf_backend_section_from_shdr           v810_elf_section_from_shdr
+#define elf_backend_fake_sections               v810_elf_fake_sections
+#define elf_backend_gc_mark_hook                v810_elf_gc_mark_hook
+#define elf_backend_special_sections            v810_elf_special_sections
+
+#define elf_backend_can_gc_sections 		1
+#define elf_backend_rela_normal			1
+
+#define bfd_elf32_bfd_is_local_label_name       v810_elf_is_local_label_name
+#define bfd_elf32_bfd_is_target_special_symbol  v810_elf_is_target_special_symbol
+
+#define bfd_elf32_bfd_reloc_type_lookup         v810_elf_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup         v810_elf_reloc_name_lookup
+#define bfd_elf32_bfd_merge_private_bfd_data    v810_elf_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags         v810_elf_set_private_flags
+#define bfd_elf32_bfd_print_private_bfd_data    v810_elf_print_private_bfd_data
+#define bfd_elf32_bfd_relax_section             v810_elf_relax_section
+
+#define elf_symbol_leading_char                 '_'
+
+#undef  elf32_bed
+#define elf32_bed elf32_v810_bed
+
+#include "elf32-target.h"
diff -Naur binutils-2.27-pure/bfd/libbfd.h binutils-2.27/bfd/libbfd.h
--- binutils-2.27-pure/bfd/libbfd.h	2016-08-03 03:36:51.000000000 -0400
+++ binutils-2.27/bfd/libbfd.h	2022-02-10 13:50:25.511346800 -0500
@@ -1974,6 +1974,12 @@
   "BFD_RELOC_NDS32_TLS_LE_15S0",
   "BFD_RELOC_NDS32_TLS_LE_15S1",
   "BFD_RELOC_NDS32_TLS_LE_15S2",
+  "BFD_RELOC_V810_9_PCREL",
+  "BFD_RELOC_V810_26_PCREL",
+  "BFD_RELOC_V810_SDA_16_16_OFFSET",
+  "BFD_RELOC_V810_ZDA_16_16_OFFSET",
+  "BFD_RELOC_V810_TDA_16_16_OFFSET",
+  "BFD_RELOC_V810_ALIGN",
   "BFD_RELOC_V850_9_PCREL",
   "BFD_RELOC_V850_22_PCREL",
   "BFD_RELOC_V850_SDA_16_16_OFFSET",
diff -Naur binutils-2.27-pure/bfd/reloc.c binutils-2.27/bfd/reloc.c
--- binutils-2.27-pure/bfd/reloc.c	2016-08-03 03:36:51.000000000 -0400
+++ binutils-2.27/bfd/reloc.c	2022-02-10 13:50:25.527347700 -0500
@@ -4341,6 +4341,32 @@
 
 
 ENUM
+  BFD_RELOC_V810_9_PCREL
+ENUMDOC
+  This is a 9-bit reloc
+ENUM
+  BFD_RELOC_V810_26_PCREL
+ENUMDOC
+  This is a 26-bit reloc
+ENUM
+  BFD_RELOC_V810_SDA_16_16_OFFSET
+ENUMDOC
+  This is a 16 bit offset from the short data area pointer.
+ENUM
+  BFD_RELOC_V810_ZDA_16_16_OFFSET
+ENUMDOC
+  This is a 16 bit offset from the zero data area pointer.
+ENUM
+  BFD_RELOC_V810_TDA_16_16_OFFSET
+ENUMDOC
+  This is a 16 bit offset from the thread data area pointer.
+ENUM
+  BFD_RELOC_V810_ALIGN
+ENUMDOC
+  Used to maintain alignment whilst relaxing.
+
+
+ENUM
   BFD_RELOC_V850_9_PCREL
 ENUMDOC
   This is a 9-bit reloc
diff -Naur binutils-2.27-pure/bfd/targets.c binutils-2.27/bfd/targets.c
--- binutils-2.27-pure/bfd/targets.c	2016-08-03 03:36:51.000000000 -0400
+++ binutils-2.27/bfd/targets.c	2022-02-10 13:50:25.541348500 -0500
@@ -881,6 +881,7 @@
 extern const bfd_target tilegx_elf64_be_vec;
 extern const bfd_target tilegx_elf64_le_vec;
 extern const bfd_target tilepro_elf32_vec;
+extern const bfd_target v810_elf32_vec;
 extern const bfd_target v800_elf32_vec;
 extern const bfd_target v850_elf32_vec;
 extern const bfd_target ft32_elf32_vec;
@@ -1400,6 +1401,7 @@
 
 	&ft32_elf32_vec,
 
+	&v810_elf32_vec,
 	&v800_elf32_vec,
 	&v850_elf32_vec,
 
diff -Naur binutils-2.27-pure/binutils/dwarf.c binutils-2.27/binutils/dwarf.c
--- binutils-2.27-pure/binutils/dwarf.c	2016-08-03 03:36:51.000000000 -0400
+++ binutils-2.27/binutils/dwarf.c	2022-02-10 13:50:25.555349400 -0500
@@ -4524,7 +4524,7 @@
 
   while (1)
     {
-      printf ("    %8.8lx ", offset + (start - *start_ptr));
+      printf ("    %8.8lx ", offset + (long) (start - *start_ptr));
 
       if (start >= section_end)
 	{
diff -Naur binutils-2.27-pure/binutils/readelf.c binutils-2.27/binutils/readelf.c
--- binutils-2.27-pure/binutils/readelf.c	2016-08-03 03:36:51.000000000 -0400
+++ binutils-2.27/binutils/readelf.c	2022-02-10 13:50:25.575350500 -0500
@@ -146,6 +146,7 @@
 #include "elf/tic6x.h"
 #include "elf/tilegx.h"
 #include "elf/tilepro.h"
+#include "elf/v810.h"
 #include "elf/v850.h"
 #include "elf/vax.h"
 #include "elf/visium.h"
@@ -787,6 +788,7 @@
     case EM_TI_C6000:
     case EM_TILEGX:
     case EM_TILEPRO:
+    case EM_PCFX_V810:
     case EM_V800:
     case EM_V850:
     case EM_CYGNUS_V850:
@@ -1225,6 +1227,9 @@
 	  rtype = elf_spu_reloc_type (type);
 	  break;
 
+	case EM_PCFX_V810:
+	  rtype = v810_reloc_type (type);
+	  break;
 	case EM_V800:
 	  rtype = v800_reloc_type (type);
 	  break;
@@ -2212,6 +2217,7 @@
     case EM_CYGNUS_M32R:
     case EM_M32R:		return "Renesas M32R (formerly Mitsubishi M32r)";
     case EM_CYGNUS_V850:
+    case EM_PCFX_V810:		return "NEC V810";
     case EM_V800:		return "Renesas V850 (using RH850 ABI)";
     case EM_V850:		return "Renesas V850";
     case EM_CYGNUS_MN10300:
@@ -11636,6 +11642,8 @@
       return reloc_type == 2; /* R_TILEGX_32.  */
     case EM_TILEPRO:
       return reloc_type == 1; /* R_TILEPRO_32.  */
+    case EM_PCFX_V810:
+      return reloc_type == 6; /* R_V810_ABS32.  */
     case EM_CYGNUS_V850:
     case EM_V850:
       return reloc_type == 6; /* R_V850_ABS32.  */
diff -Naur binutils-2.27-pure/config.sub binutils-2.27/config.sub
--- binutils-2.27-pure/config.sub	2016-08-03 03:36:51.000000000 -0400
+++ binutils-2.27/config.sub	2022-02-10 13:50:25.591351400 -0500
@@ -312,7 +312,7 @@
 	| spu \
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
-	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| v810 | v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
 	| visium \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
@@ -441,7 +441,7 @@
 	| tile*-* \
 	| tron-* \
 	| ubicom32-* \
-	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
+	| v810-* | v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
 	| visium-* \
 	| we32k-* \
@@ -1206,10 +1206,6 @@
 		basic_machine=a29k-nyu
 		os=-sym1
 		;;
-	v810 | necv810)
-		basic_machine=v810-nec
-		os=-none
-		;;
 	vaxv)
 		basic_machine=vax-dec
 		os=-sysv
diff -Naur binutils-2.27-pure/configure binutils-2.27/configure
--- binutils-2.27-pure/configure	2016-08-03 03:54:55.000000000 -0400
+++ binutils-2.27/configure	2022-02-10 13:50:25.679356400 -0500
@@ -3968,9 +3968,6 @@
   tilepro*-*-*)
     noconfigdirs="$noconfigdirs gdb sim"
     ;;
-  v810-*-*)
-    noconfigdirs="$noconfigdirs bfd binutils gas gdb ld opcodes target-libgloss"
-    ;;
   vax-*-*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
diff -Naur binutils-2.27-pure/configure.ac binutils-2.27/configure.ac
--- binutils-2.27-pure/configure.ac	2016-08-03 04:37:38.000000000 -0400
+++ binutils-2.27/configure.ac	2022-02-10 13:50:25.697357500 -0500
@@ -1304,9 +1304,6 @@
   tilepro*-*-*)
     noconfigdirs="$noconfigdirs gdb sim"
     ;;
-  v810-*-*)
-    noconfigdirs="$noconfigdirs bfd binutils gas gdb ld opcodes target-libgloss"
-    ;;
   vax-*-*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
diff -Naur binutils-2.27-pure/elfcpp/elfcpp.h binutils-2.27/elfcpp/elfcpp.h
--- binutils-2.27-pure/elfcpp/elfcpp.h	2016-08-03 03:36:51.000000000 -0400
+++ binutils-2.27/elfcpp/elfcpp.h	2022-02-10 13:50:25.711358300 -0500
@@ -278,6 +278,8 @@
   EM_FRV = 0x5441,
   // Infineon Technologies 16-bit microcontroller with C166-V2 core.
   EM_X16X = 0x4688,
+  // NEC V810
+  EM_PCFX_V810 = 0x9081,
   // Xstorym16
   EM_XSTORMY16 = 0xad45,
   // Renesas M32C
diff -Naur binutils-2.27-pure/gas/Makefile.am binutils-2.27/gas/Makefile.am
--- binutils-2.27-pure/gas/Makefile.am	2016-08-03 03:36:51.000000000 -0400
+++ binutils-2.27/gas/Makefile.am	2022-02-10 13:50:25.726359100 -0500
@@ -191,6 +191,7 @@
 	config/tc-tic6x.c \
 	config/tc-tilegx.c \
 	config/tc-tilepro.c \
+	config/tc-v810.c \
 	config/tc-v850.c \
 	config/tc-vax.c \
 	config/tc-visium.c \
@@ -264,6 +265,7 @@
 	config/tc-tic6x.h \
 	config/tc-tilegx.h \
 	config/tc-tilepro.h \
+	config/tc-v810.h \
 	config/tc-v850.h \
 	config/tc-vax.h \
 	config/tc-visium.h \
diff -Naur binutils-2.27-pure/gas/Makefile.in binutils-2.27/gas/Makefile.in
--- binutils-2.27-pure/gas/Makefile.in	2016-08-03 04:16:28.000000000 -0400
+++ binutils-2.27/gas/Makefile.in	2022-02-10 13:50:25.741360000 -0500
@@ -485,6 +485,7 @@
 	config/tc-tic6x.c \
 	config/tc-tilegx.c \
 	config/tc-tilepro.c \
+	config/tc-v810.c \
 	config/tc-v850.c \
 	config/tc-vax.c \
 	config/tc-visium.c \
@@ -558,6 +559,7 @@
 	config/tc-tic6x.h \
 	config/tc-tilegx.h \
 	config/tc-tilepro.h \
+	config/tc-v810.h \
 	config/tc-v850.h \
 	config/tc-vax.h \
 	config/tc-visium.h \
@@ -913,6 +915,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-tic6x.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-tilegx.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-tilepro.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-v810.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-v850.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-vax.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-visium.Po@am__quote@
@@ -1815,6 +1818,20 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-tilepro.obj `if test -f 'config/tc-tilepro.c'; then $(CYGPATH_W) 'config/tc-tilepro.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-tilepro.c'; fi`
 
+tc-v810.o: config/tc-v810.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-v810.o -MD -MP -MF $(DEPDIR)/tc-v810.Tpo -c -o tc-v810.o `test -f 'config/tc-v810.c' || echo '$(srcdir)/'`config/tc-v810.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-v810.Tpo $(DEPDIR)/tc-v810.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-v810.c' object='tc-v810.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-v810.o `test -f 'config/tc-v810.c' || echo '$(srcdir)/'`config/tc-v810.c
+
+tc-v810.obj: config/tc-v810.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-v810.obj -MD -MP -MF $(DEPDIR)/tc-v810.Tpo -c -o tc-v810.obj `if test -f 'config/tc-v810.c'; then $(CYGPATH_W) 'config/tc-v810.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-v810.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-v810.Tpo $(DEPDIR)/tc-v810.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-v810.c' object='tc-v810.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-v810.obj `if test -f 'config/tc-v810.c'; then $(CYGPATH_W) 'config/tc-v810.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-v810.c'; fi`
+
 tc-v850.o: config/tc-v850.c
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-v850.o -MD -MP -MF $(DEPDIR)/tc-v850.Tpo -c -o tc-v850.o `test -f 'config/tc-v850.c' || echo '$(srcdir)/'`config/tc-v850.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-v850.Tpo $(DEPDIR)/tc-v850.Po
diff -Naur binutils-2.27-pure/gas/config/tc-v810.c binutils-2.27/gas/config/tc-v810.c
--- binutils-2.27-pure/gas/config/tc-v810.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/config/tc-v810.c	2022-02-10 13:50:25.756360800 -0500
@@ -0,0 +1,2073 @@
+/* tc-v810.c -- Assembler code for the NEC V810
+   Copyright (C) 1996-2016 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+#include "opcode/v810.h"
+#include "dwarf2dbg.h"
+
+/* Sign-extend a 16-bit number.  */
+#define SEXT16(x)       ((((x) & 0xffff) ^ (~0x7fff)) + 0x8000)
+
+/* Set to TRUE if we want to be pedantic about signed overflows.  */
+static bfd_boolean warn_signed_overflows   = FALSE;
+static bfd_boolean warn_unsigned_overflows = FALSE;
+
+/* Indicates the target BFD machine number.  */
+static int machine = -1;
+
+/* Indicates the target processor(s) for the assemble.  */
+static int processor_mask = 0;
+
+/* Structure to hold information about predefined registers.  */
+struct reg_name
+{
+  const char *name;
+  int value;
+  unsigned int processors;
+};
+
+/* Generic assembler global variables which must be defined by all
+   targets.  */
+
+/* Characters which always start a comment.  */
+const char comment_chars[] = "#";
+
+/* Characters which start a comment at the beginning of a line.  */
+const char line_comment_chars[] = ";#";
+
+/* Characters which may be used to separate multiple commands on a
+   single line.  */
+const char line_separator_chars[] = ";";
+
+/* Characters which are used to indicate an exponent in a floating
+   point number.  */
+const char EXP_CHARS[] = "eE";
+
+/* Characters which mean that a number is a floating point constant,
+   as in 0d1.0.  */
+const char FLT_CHARS[] = "dD";
+
+const relax_typeS md_relax_table[] =
+{
+  /* V810 9bit or 26bit - conditional branches. */
+#define SUBTYPE_COND_9_26 0
+  {0xfe,          -0x100,         2, SUBTYPE_COND_9_26 + 1},
+  {0x1fffffe + 2, -0x2000000 + 2, 6, 0},
+
+  /* V810 9bit or 26bit - unconditional branches. */
+#define SUBTYPE_UNCOND_9_26 2
+  {0xfe,          -0x100,         2, SUBTYPE_UNCOND_9_26 + 1},
+  {0x1fffffe + 4, -0x2000000 + 4, 4, 0},
+};
+
+static int v810_relax = 0;
+
+/* Fixups.  */
+#define MAX_INSN_FIXUPS   5
+
+struct v810_fixup
+{
+  expressionS exp;
+  int opindex;
+  bfd_reloc_code_real_type reloc;
+};
+
+struct v810_fixup fixups[MAX_INSN_FIXUPS];
+static int fc;
+
+struct v810_seg_entry
+{
+  segT s;
+  const char *name;
+  flagword flags;
+};
+
+struct v810_seg_entry v810_seg_table[] =
+{
+  { NULL, ".sdata",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
+    | SEC_SMALL_DATA },
+  { NULL, ".tdata",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS },
+  { NULL, ".zdata",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS },
+  { NULL, ".sbss",
+    SEC_ALLOC | SEC_SMALL_DATA },
+  { NULL, ".tbss",
+    SEC_ALLOC },
+  { NULL, ".zbss",
+    SEC_ALLOC},
+  { NULL, ".rosdata",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY | SEC_DATA
+    | SEC_HAS_CONTENTS | SEC_SMALL_DATA },
+  { NULL, ".rozdata",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY | SEC_DATA
+    | SEC_HAS_CONTENTS },
+  { NULL, ".scommon",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
+    | SEC_SMALL_DATA | SEC_IS_COMMON },
+  { NULL, ".tcommon",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
+    | SEC_IS_COMMON },
+  { NULL, ".zcommon",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
+    | SEC_IS_COMMON },
+  { NULL, ".bss",
+    SEC_ALLOC }
+};
+
+#define SDATA_SECTION   0
+#define TDATA_SECTION   1
+#define ZDATA_SECTION   2
+#define SBSS_SECTION    3
+#define TBSS_SECTION    4
+#define ZBSS_SECTION    5
+#define ROSDATA_SECTION 6
+#define ROZDATA_SECTION 7
+#define SCOMMON_SECTION 8
+#define TCOMMON_SECTION 9
+#define ZCOMMON_SECTION 10
+#define BSS_SECTION     11
+
+static void
+do_v810_seg (int i, subsegT sub)
+{
+  struct v810_seg_entry *seg = v810_seg_table + i;
+
+  obj_elf_section_change_hook ();
+
+  if (seg->s != NULL)
+    subseg_set (seg->s, sub);
+  else
+    {
+      seg->s = subseg_new (seg->name, sub);
+      bfd_set_section_flags (stdoutput, seg->s, seg->flags);
+      if ((seg->flags & SEC_LOAD) == 0)
+        seg_info (seg->s)->bss = 1;
+    }
+}
+
+static void
+v810_seg (int i)
+{
+  subsegT sub = get_absolute_expression ();
+
+  do_v810_seg (i, sub);
+  demand_empty_rest_of_line ();
+}
+
+static void
+v810_offset (int ignore ATTRIBUTE_UNUSED)
+{
+  char *pfrag;
+  int temp = get_absolute_expression ();
+
+  pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, (symbolS *)0,
+                    (offsetT) temp, (char *) 0);
+  *pfrag = 0;
+
+  demand_empty_rest_of_line ();
+}
+
+/* Copied from obj_elf_common() in gas/config/obj-elf.c.  */
+
+static void
+v810_comm (int area)
+{
+  char *name;
+  char c;
+  char *p;
+  int temp;
+  unsigned int size;
+  symbolS *symbolP;
+  int have_align;
+
+  c = get_symbol_name (&name);
+
+  /* Just after name is now '\0'.  */
+  p = input_line_pointer;
+  *p = c;
+
+  SKIP_WHITESPACE ();
+
+  if (*input_line_pointer != ',')
+    {
+      as_bad (_("Expected comma after symbol-name"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  /* Skip ','.  */
+  input_line_pointer++;
+
+  if ((temp = get_absolute_expression ()) < 0)
+    {
+      /* xgettext:c-format  */
+      as_bad (_(".COMMon length (%d.) < 0! Ignored."), temp);
+      ignore_rest_of_line ();
+      return;
+    }
+
+  size = temp;
+  *p = 0;
+  symbolP = symbol_find_or_make (name);
+  *p = c;
+
+  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
+    {
+      as_bad (_("Ignoring attempt to re-define symbol"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  if (S_GET_VALUE (symbolP) != 0)
+    {
+      if (S_GET_VALUE (symbolP) != size)
+        /* xgettext:c-format  */
+        as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
+                 S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
+    }
+
+  know (symbol_get_frag (symbolP) == &zero_address_frag);
+
+  if (*input_line_pointer != ',')
+    have_align = 0;
+  else
+    {
+      have_align = 1;
+      input_line_pointer++;
+      SKIP_WHITESPACE ();
+    }
+
+  if (! have_align || *input_line_pointer != '"')
+    {
+      if (! have_align)
+        temp = 0;
+      else
+        {
+          temp = get_absolute_expression ();
+
+          if (temp < 0)
+            {
+              temp = 0;
+              as_warn (_("Common alignment negative; 0 assumed"));
+            }
+        }
+
+      if (symbol_get_obj (symbolP)->local)
+        {
+          segT old_sec;
+          int old_subsec;
+          char *pfrag;
+          int align;
+          flagword applicable;
+
+          old_sec = now_seg;
+          old_subsec = now_subseg;
+
+          applicable = bfd_applicable_section_flags (stdoutput);
+
+          applicable &= SEC_ALLOC;
+
+          switch (area)
+            {
+            case SCOMMON_SECTION:
+              do_v810_seg (SBSS_SECTION, 0);
+              break;
+
+            case ZCOMMON_SECTION:
+              do_v810_seg (ZBSS_SECTION, 0);
+              break;
+
+            case TCOMMON_SECTION:
+              do_v810_seg (TBSS_SECTION, 0);
+              break;
+            }
+
+          if (temp)
+            {
+              /* Convert to a power of 2 alignment.  */
+              for (align = 0; (temp & 1) == 0; temp >>= 1, ++align)
+                ;
+
+              if (temp != 1)
+                {
+                  as_bad (_("Common alignment not a power of 2"));
+                  ignore_rest_of_line ();
+                  return;
+                }
+            }
+          else
+            align = 0;
+
+          record_alignment (now_seg, align);
+
+          if (align)
+            frag_align (align, 0, 0);
+
+          switch (area)
+            {
+            case SCOMMON_SECTION:
+              if (S_GET_SEGMENT (symbolP) == v810_seg_table[SBSS_SECTION].s)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+              break;
+
+            case ZCOMMON_SECTION:
+              if (S_GET_SEGMENT (symbolP) == v810_seg_table[ZBSS_SECTION].s)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+              break;
+
+            case TCOMMON_SECTION:
+              if (S_GET_SEGMENT (symbolP) == v810_seg_table[TBSS_SECTION].s)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+              break;
+
+            default:
+              abort ();
+            }
+
+          symbol_set_frag (symbolP, frag_now);
+          pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                            (offsetT) size, (char *) 0);
+          *pfrag = 0;
+          S_SET_SIZE (symbolP, size);
+
+          switch (area)
+            {
+            case SCOMMON_SECTION:
+              S_SET_SEGMENT (symbolP, v810_seg_table[SBSS_SECTION].s);
+              break;
+
+            case ZCOMMON_SECTION:
+              S_SET_SEGMENT (symbolP, v810_seg_table[ZBSS_SECTION].s);
+              break;
+
+            case TCOMMON_SECTION:
+              S_SET_SEGMENT (symbolP, v810_seg_table[TBSS_SECTION].s);
+              break;
+
+            default:
+              abort ();
+            }
+
+          S_CLEAR_EXTERNAL (symbolP);
+          obj_elf_section_change_hook ();
+          subseg_set (old_sec, old_subsec);
+        }
+      else
+        {
+          segT   old_sec;
+          int    old_subsec;
+
+        allocate_common:
+          old_sec = now_seg;
+          old_subsec = now_subseg;
+
+          S_SET_VALUE (symbolP, (valueT) size);
+          S_SET_ALIGN (symbolP, temp);
+          S_SET_EXTERNAL (symbolP);
+
+          switch (area)
+            {
+            case SCOMMON_SECTION:
+            case ZCOMMON_SECTION:
+            case TCOMMON_SECTION:
+              do_v810_seg (area, 0);
+              S_SET_SEGMENT (symbolP, v810_seg_table[area].s);
+              break;
+
+            default:
+              abort ();
+            }
+
+          obj_elf_section_change_hook ();
+          subseg_set (old_sec, old_subsec);
+        }
+    }
+  else
+    {
+      input_line_pointer++;
+
+      /* @@ Some use the dot, some don't.  Can we get some consistency??  */
+      if (*input_line_pointer == '.')
+        input_line_pointer++;
+
+      /* @@ Some say data, some say bss.  */
+      if (strncmp (input_line_pointer, "bss\"", 4)
+          && strncmp (input_line_pointer, "data\"", 5))
+        {
+          while (*--input_line_pointer != '"')
+            ;
+          input_line_pointer--;
+          goto bad_common_segment;
+        }
+
+      while (*input_line_pointer++ != '"')
+        ;
+
+      goto allocate_common;
+    }
+
+  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
+
+  demand_empty_rest_of_line ();
+  return;
+
+  {
+  bad_common_segment:
+    p = input_line_pointer;
+    while (*p && *p != '\n')
+      p++;
+    c = *p;
+    *p = '\0';
+    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
+    *p = c;
+    input_line_pointer = p;
+    ignore_rest_of_line ();
+    return;
+  }
+}
+
+static void
+set_machine (int number)
+{
+  machine = number;
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, machine);
+
+  switch (machine)
+    {
+    case 0:                SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V810);    break;
+    case bfd_mach_v810:    SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V810);    break;
+    }
+}
+
+/* The target specific pseudo-ops which we support.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  { "sdata",            v810_seg,               SDATA_SECTION           },
+  { "tdata",            v810_seg,               TDATA_SECTION           },
+  { "zdata",            v810_seg,               ZDATA_SECTION           },
+  { "sbss",             v810_seg,               SBSS_SECTION            },
+  { "tbss",             v810_seg,               TBSS_SECTION            },
+  { "zbss",             v810_seg,               ZBSS_SECTION            },
+  { "rosdata",          v810_seg,               ROSDATA_SECTION         },
+  { "rozdata",          v810_seg,               ROZDATA_SECTION         },
+  { "bss",              v810_seg,               BSS_SECTION             },
+  { "offset",           v810_offset,            0                       },
+  { "word",             cons,                   4                       },
+  { "zcomm",            v810_comm,              ZCOMMON_SECTION         },
+  { "scomm",            v810_comm,              SCOMMON_SECTION         },
+  { "tcomm",            v810_comm,              TCOMMON_SECTION         },
+  { "v810",             set_machine,            0                       },
+  { NULL,               NULL,                   0                       }
+};
+
+/* Opcode hash table.  */
+static struct hash_control *v810_hash;
+
+/* This table is sorted.  Suitable for searching by a binary search.  */
+static const struct reg_name pre_defined_registers[] =
+{
+  { "fp",   2, PROCESSOR_ALL },         /* fp - frame ptr.  */
+  { "gp",   4, PROCESSOR_ALL },         /* gp - global ptr.  */
+  { "lp",  31, PROCESSOR_ALL },         /* lp - link ptr.  */
+  { "r0",   0, PROCESSOR_ALL },
+  { "r1",   1, PROCESSOR_ALL },
+  { "r10", 10, PROCESSOR_ALL },
+  { "r11", 11, PROCESSOR_ALL },
+  { "r12", 12, PROCESSOR_ALL },
+  { "r13", 13, PROCESSOR_ALL },
+  { "r14", 14, PROCESSOR_ALL },
+  { "r15", 15, PROCESSOR_ALL },
+  { "r16", 16, PROCESSOR_ALL },
+  { "r17", 17, PROCESSOR_ALL },
+  { "r18", 18, PROCESSOR_ALL },
+  { "r19", 19, PROCESSOR_ALL },
+  { "r2",   2, PROCESSOR_ALL },
+  { "r20", 20, PROCESSOR_ALL },
+  { "r21", 21, PROCESSOR_ALL },
+  { "r22", 22, PROCESSOR_ALL },
+  { "r23", 23, PROCESSOR_ALL },
+  { "r24", 24, PROCESSOR_ALL },
+  { "r25", 25, PROCESSOR_ALL },
+  { "r26", 26, PROCESSOR_ALL },
+  { "r27", 27, PROCESSOR_ALL },
+  { "r28", 28, PROCESSOR_ALL },
+  { "r29", 29, PROCESSOR_ALL },
+  { "r3",   3, PROCESSOR_ALL },
+  { "r30", 30, PROCESSOR_ALL },
+  { "r31", 31, PROCESSOR_ALL },
+  { "r4",   4, PROCESSOR_ALL },
+  { "r5",   5, PROCESSOR_ALL },
+  { "r6",   6, PROCESSOR_ALL },
+  { "r7",   7, PROCESSOR_ALL },
+  { "r8",   8, PROCESSOR_ALL },
+  { "r9",   9, PROCESSOR_ALL },
+  { "sp",   3, PROCESSOR_ALL },         /* sp - stack ptr.  */
+  { "tp",   5, PROCESSOR_ALL },         /* tp - thread ptr.  */
+  { "zero", 0, PROCESSOR_ALL },
+};
+
+#define REG_NAME_CNT                                            \
+  (sizeof (pre_defined_registers) / sizeof (struct reg_name))
+
+static const struct reg_name system_registers[] =
+{
+  { "adtre",       25, PROCESSOR_ALL },
+  { "chcw",        24, PROCESSOR_ALL },
+  { "ecr",          4, PROCESSOR_ALL },
+  { "eipc",         0, PROCESSOR_ALL },
+  { "eipsw",        1, PROCESSOR_ALL },
+  { "fepc",         2, PROCESSOR_ALL },
+  { "fepsw",        3, PROCESSOR_ALL },
+  { "psw",          5, PROCESSOR_ALL },
+  { "sr0",          0, PROCESSOR_ALL },
+  { "sr1",          1, PROCESSOR_ALL },
+  { "sr2",          2, PROCESSOR_ALL },
+  { "sr24",        24, PROCESSOR_ALL },
+  { "sr25",        25, PROCESSOR_ALL },
+  { "sr3",          3, PROCESSOR_ALL },
+  { "sr4",          4, PROCESSOR_ALL },
+  { "sr5",          5, PROCESSOR_ALL },
+  { "sr6",          6, PROCESSOR_ALL },
+  { "sr7",          7, PROCESSOR_ALL },
+  { "tkcw",         7, PROCESSOR_ALL },
+};
+
+#define SYSREG_NAME_CNT                                         \
+  (sizeof (system_registers) / sizeof (struct reg_name))
+
+
+static const struct reg_name cc_names[] =
+{
+  { "c",  0x1, PROCESSOR_ALL },
+  { "e",  0x2, PROCESSOR_ALL },
+  { "ge", 0xe, PROCESSOR_ALL },
+  { "gt", 0xf, PROCESSOR_ALL },
+  { "h",  0xb, PROCESSOR_ALL },
+  { "l",  0x1, PROCESSOR_ALL },
+  { "le", 0x7, PROCESSOR_ALL },
+  { "lt", 0x6, PROCESSOR_ALL },
+  { "n",  0x4, PROCESSOR_ALL },
+  { "nc", 0x9, PROCESSOR_ALL },
+  { "ne", 0xa, PROCESSOR_ALL },
+  { "nh", 0x3, PROCESSOR_ALL },
+  { "nl", 0x9, PROCESSOR_ALL },
+  { "ns", 0xc, PROCESSOR_ALL },
+  { "nv", 0x8, PROCESSOR_ALL },
+  { "nz", 0xa, PROCESSOR_ALL },
+  { "p",  0xc, PROCESSOR_ALL },
+  { "s",  0x4, PROCESSOR_ALL },
+  { "t",  0x5, PROCESSOR_ALL },
+  { "v",  0x0, PROCESSOR_ALL },
+  { "z",  0x2, PROCESSOR_ALL },
+};
+
+#define CC_NAME_CNT                                     \
+  (sizeof (cc_names) / sizeof (struct reg_name))
+
+/* Do a binary search of the given register table to see if NAME is a
+   valid regiter name.  Return the register number from the array on
+   success, or -1 on failure.  */
+
+static int
+reg_name_search (const struct reg_name *regs,
+                 int regcount,
+                 const char *name,
+                 bfd_boolean accept_numbers)
+{
+  int middle, low, high;
+  int cmp;
+  symbolS *symbolP;
+
+  /* If the register name is a symbol, then evaluate it.  */
+  if ((symbolP = symbol_find (name)) != NULL)
+    {
+      /* If the symbol is an alias for another name then use that.
+         If the symbol is an alias for a number, then return the number.  */
+      if (symbol_equated_p (symbolP))
+        name
+          = S_GET_NAME (symbol_get_value_expression (symbolP)->X_add_symbol);
+      else if (accept_numbers)
+        {
+          int reg = S_GET_VALUE (symbolP);
+          return reg;
+        }
+
+      /* Otherwise drop through and try parsing name normally.  */
+    }
+
+  low = 0;
+  high = regcount - 1;
+
+  do
+    {
+      middle = (low + high) / 2;
+      cmp = strcasecmp (name, regs[middle].name);
+      if (cmp < 0)
+        high = middle - 1;
+      else if (cmp > 0)
+        low = middle + 1;
+      else
+        return ((regs[middle].processors & processor_mask)
+                ? regs[middle].value
+                : -1);
+    }
+  while (low <= high);
+  return -1;
+}
+
+/* Summary of register_name().
+
+   in: Input_line_pointer points to 1st char of operand.
+
+   out: An expressionS.
+        The operand may have been a register: in this case, X_op == O_register,
+        X_add_number is set to the register number, and truth is returned.
+        Input_line_pointer->(next non-blank) char after operand, or is in
+        its original state.  */
+
+static bfd_boolean
+register_name (expressionS *expressionP)
+{
+  int reg_number;
+  char *name;
+  char *start;
+  char c;
+
+  /* Find the spelling of the operand.  */
+  start = input_line_pointer;
+  c = get_symbol_name (&name);
+
+  reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT,
+                                name, FALSE);
+
+  /* Put back the delimiting char.  */
+  (void) restore_line_pointer (c);
+
+  expressionP->X_add_symbol = NULL;
+  expressionP->X_op_symbol  = NULL;
+
+  /* Look to see if it's in the register table.  */
+  if (reg_number >= 0)
+    {
+      expressionP->X_op         = O_register;
+      expressionP->X_add_number = reg_number;
+
+      return TRUE;
+    }
+
+  /* Reset the line as if we had not done anything.  */
+  input_line_pointer = start;
+
+  expressionP->X_op = O_illegal;
+
+  return FALSE;
+}
+
+/* Summary of system_register_name().
+
+   in:  INPUT_LINE_POINTER points to 1st char of operand.
+        EXPRESSIONP points to an expression structure to be filled in.
+        ACCEPT_NUMBERS is true iff numerical register names may be used.
+
+   out: An expressionS structure in expressionP.
+        The operand may have been a register: in this case, X_op == O_register,
+        X_add_number is set to the register number, and truth is returned.
+        Input_line_pointer->(next non-blank) char after operand, or is in
+        its original state.  */
+
+static bfd_boolean
+system_register_name (expressionS *expressionP,
+                      bfd_boolean accept_numbers)
+{
+  int reg_number;
+  char *name;
+  char *start;
+  char c;
+
+  /* Find the spelling of the operand.  */
+  start = input_line_pointer;
+  c = get_symbol_name (&name);
+  reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name,
+                                accept_numbers);
+
+  /* Put back the delimiting char.  */
+  (void) restore_line_pointer (c);
+
+  if (reg_number < 0
+      && accept_numbers)
+    {
+      /* Reset input_line pointer.  */
+      input_line_pointer = start;
+
+      if (ISDIGIT (*input_line_pointer))
+        {
+          reg_number = strtol (input_line_pointer, &input_line_pointer, 0);
+        }
+    }
+
+  expressionP->X_add_symbol = NULL;
+  expressionP->X_op_symbol  = NULL;
+
+  /* Look to see if it's in the register table.  */
+  if (reg_number >= 0)
+    {
+      expressionP->X_op         = O_register;
+      expressionP->X_add_number = reg_number;
+
+      return TRUE;
+    }
+
+  /* Reset the line as if we had not done anything.  */
+  input_line_pointer = start;
+
+  expressionP->X_op = O_illegal;
+
+  return FALSE;
+}
+
+/* Summary of cc_name().
+
+   in: INPUT_LINE_POINTER points to 1st char of operand.
+
+   out: An expressionS.
+        The operand may have been a register: in this case, X_op == O_register,
+        X_add_number is set to the register number, and truth is returned.
+        Input_line_pointer->(next non-blank) char after operand, or is in
+        its original state.  */
+
+static bfd_boolean
+cc_name (expressionS *expressionP,
+         bfd_boolean accept_numbers)
+{
+  int reg_number;
+  char *name;
+  char *start;
+  char c;
+
+  /* Find the spelling of the operand.  */
+  start = input_line_pointer;
+  c = get_symbol_name (&name);
+  reg_number = reg_name_search (cc_names, CC_NAME_CNT, name, accept_numbers);
+
+  /* Put back the delimiting char.  */
+  (void) restore_line_pointer (c);
+
+  if (reg_number < 0
+      && accept_numbers)
+    {
+      /* Reset input_line pointer.  */
+      input_line_pointer = start;
+
+      if (ISDIGIT (*input_line_pointer))
+        {
+          reg_number = strtol (input_line_pointer, &input_line_pointer, 0);
+        }
+    }
+
+  expressionP->X_add_symbol = NULL;
+  expressionP->X_op_symbol  = NULL;
+
+  /* Look to see if it's in the register table.  */
+  if (reg_number >= 0)
+    {
+      expressionP->X_op         = O_constant;
+      expressionP->X_add_number = reg_number;
+
+      return TRUE;
+    }
+
+  /* Reset the line as if we had not done anything.  */
+  input_line_pointer = start;
+
+  expressionP->X_op = O_illegal;
+  expressionP->X_add_number = 0;
+
+  return FALSE;
+}
+
+const char *md_shortopts = "m:";
+
+struct option md_longopts[] =
+{
+  {NULL, no_argument, NULL, 0}
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+void
+md_show_usage (FILE *stream)
+{
+  fprintf (stream, _(" V810 options:\n"));
+  fprintf (stream, _("  -mwarn-signed-overflow    Warn if signed immediate values overflow\n"));
+  fprintf (stream, _("  -mwarn-unsigned-overflow  Warn if unsigned immediate values overflow\n"));
+  fprintf (stream, _("  -mv810                    The code is targeted at the v810\n"));
+  fprintf (stream, _("  -mrelax                   Enable relaxation\n"));
+}
+
+int
+md_parse_option (int c, const char *arg)
+{
+  if (c != 'm')
+    {
+      return 0;
+    }
+
+  if (strcmp (arg, "warn-signed-overflow") == 0)
+    warn_signed_overflows = TRUE;
+
+  else if (strcmp (arg, "warn-unsigned-overflow") == 0)
+    warn_unsigned_overflows = TRUE;
+
+  else if (strcmp (arg, "v810") == 0)
+    {
+      machine = 0;
+      SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V810);
+    }
+  else if (strcmp (arg, "relax") == 0)
+    v810_relax = 1;
+  else
+    return 0;
+
+  return 1;
+}
+
+symbolS *
+md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+const char *
+md_atof (int type, char *litp, int *sizep)
+{
+  return ieee_md_atof (type, litp, sizep, FALSE);
+}
+
+/* Very gross.  */
+
+void
+md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
+                 asection *sec,
+                 fragS *fragP)
+{
+  union u
+  {
+    bfd_reloc_code_real_type fx_r_type;
+    char * fr_opcode;
+  }
+  opcode_converter;
+  subseg_change (sec, 0);
+
+  opcode_converter.fr_opcode = fragP->fr_opcode;
+
+  subseg_change (sec, 0);
+
+  /* In range conditional or unconditional branch.  */
+  if (fragP->fr_subtype == SUBTYPE_COND_9_26
+      || fragP->fr_subtype == SUBTYPE_UNCOND_9_26)
+
+    {
+      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
+               fragP->fr_offset, 1,
+               BFD_RELOC_UNUSED + opcode_converter.fx_r_type);
+      fragP->fr_fix += 2;
+    }
+  /* Out of range conditional branch.  Emit a branch around a 26bit jump.  */
+  else if (fragP->fr_subtype == SUBTYPE_COND_9_26 + 1)
+    {
+      unsigned char *buffer =
+        (unsigned char *) (fragP->fr_fix + fragP->fr_literal);
+
+      /* Reverse the condition of the first branch.  */
+      buffer[1] ^= 0x10;
+      /* Mask off all the displacement bits.  */
+      buffer[1] &= 0xfe;
+      buffer[0] &= 0x00;
+      /* Now set the displacement bits so that we branch
+         around the unconditional branch.  */
+      buffer[0] |= 0x06;
+
+      /* Now create the unconditional branch + fixup to the final
+         target.  */
+      md_number_to_chars ((char *) buffer + 2, 0x0000a800, 4);
+      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
+               fragP->fr_offset, 1, BFD_RELOC_V810_26_PCREL);
+      fragP->fr_fix += 6;
+    }
+  /* Out of range unconditional branch.  Emit a 26bit jump.  */
+  else if (fragP->fr_subtype == SUBTYPE_UNCOND_9_26 + 1)
+    {
+      md_number_to_chars (fragP->fr_fix + fragP->fr_literal, 0x0000a800, 4);
+      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
+               fragP->fr_offset, 1, BFD_RELOC_V810_26_PCREL);
+      fragP->fr_fix += 4;
+    }
+  else
+    abort ();
+}
+
+valueT
+md_section_align (asection *seg, valueT addr)
+{
+  int align = bfd_get_section_alignment (stdoutput, seg);
+  return ((addr + (1 << align) - 1) & -(1 << align));
+}
+
+void
+md_begin (void)
+{
+  const char *prev_name = "";
+  const struct v810_opcode *op;
+
+  if (strncmp (TARGET_CPU, "v810", 4) == 0)
+    {
+      if (machine == -1)
+        machine = 0;
+
+      if (!processor_mask)
+        SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V810);
+    }
+  else
+    /* xgettext:c-format  */
+    as_bad (_("Unable to determine default target processor from string: %s"),
+            TARGET_CPU);
+
+  v810_hash = hash_new ();
+
+  /* Insert unique names into hash table.  The V810 instruction set
+     has many identical opcode names that have different opcodes based
+     on the operands.  This hash table then provides a quick index to
+     the first opcode with a particular name in the opcode table.  */
+  op = v810_opcodes;
+  while (op->name)
+    {
+      if (strcmp (prev_name, op->name))
+        {
+          prev_name = (char *) op->name;
+          hash_insert (v810_hash, op->name, (char *) op);
+        }
+      op++;
+    }
+
+  v810_seg_table[BSS_SECTION].s = bss_section;
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, machine);
+}
+
+
+static bfd_reloc_code_real_type
+handle_hi016 (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    return BFD_RELOC_HI16;
+
+  if (operand->default_reloc == BFD_RELOC_HI16)
+    return BFD_RELOC_HI16;
+
+  if (operand->default_reloc == BFD_RELOC_HI16_S)
+    return BFD_RELOC_HI16;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_HI16;
+
+  *errmsg = _("hi0() relocation used on an instruction which does "
+              "not support it");
+  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
+}
+
+static bfd_reloc_code_real_type
+handle_hi16 (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    return BFD_RELOC_HI16_S;
+
+  if (operand->default_reloc == BFD_RELOC_HI16_S)
+    return BFD_RELOC_HI16_S;
+
+  if (operand->default_reloc == BFD_RELOC_HI16)
+    return BFD_RELOC_HI16_S;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_HI16_S;
+
+  *errmsg = _("hi() relocation used on an instruction which does "
+              "not support it");
+  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
+}
+
+static bfd_reloc_code_real_type
+handle_lo16 (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    return BFD_RELOC_LO16;
+
+  if (operand->default_reloc == BFD_RELOC_LO16)
+    return BFD_RELOC_LO16;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_LO16;
+
+  *errmsg = _("lo() relocation used on an instruction which does "
+              "not support it");
+  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
+}
+
+static bfd_reloc_code_real_type
+handle_sdaoff (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    return BFD_RELOC_V810_SDA_16_16_OFFSET;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_V810_SDA_16_16_OFFSET;
+
+  *errmsg = _("sdaoff() relocation used on an instruction which does not support it");
+  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
+}
+
+static bfd_reloc_code_real_type
+handle_zdaoff (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    return BFD_RELOC_V810_ZDA_16_16_OFFSET;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_V810_ZDA_16_16_OFFSET;
+
+  *errmsg = _("zdaoff() relocation used on an instruction which does not support it");
+  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
+}
+
+static bfd_reloc_code_real_type
+handle_tdaoff (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    /* Data item, not an instruction.  */
+    return BFD_RELOC_V810_TDA_16_16_OFFSET;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_V810_TDA_16_16_OFFSET;
+
+  *errmsg = _("tdaoff() relocation used on an instruction which does not support it");
+  /* Used to indicate an error condition.  */
+  return BFD_RELOC_64;
+}
+
+/* Warning: The code in this function relies upon the definitions
+   in the v810_operands[] array (defined in opcodes/v810-opc.c)
+   matching the hard coded values contained herein.  */
+
+static bfd_reloc_code_real_type
+v810_reloc_prefix (const struct v810_operand *operand, const char **errmsg)
+{
+  bfd_boolean paren_skipped = FALSE;
+
+  /* Skip leading opening parenthesis.  */
+  if (*input_line_pointer == '(')
+    {
+      ++input_line_pointer;
+      paren_skipped = TRUE;
+    }
+
+#define CHECK_(name, reloc)                                             \
+  if (strncmp (input_line_pointer, name "(", strlen (name) + 1) == 0)   \
+    {                                                                   \
+      input_line_pointer += strlen (name);                              \
+      return reloc;                                                     \
+    }
+
+  CHECK_ ("hi0",    handle_hi016(operand, errmsg)  );
+  CHECK_ ("hi",     handle_hi16(operand, errmsg)   );
+  CHECK_ ("lo",     handle_lo16 (operand, errmsg)  );
+  CHECK_ ("sdaoff", handle_sdaoff (operand, errmsg));
+  CHECK_ ("zdaoff", handle_zdaoff (operand, errmsg));
+  CHECK_ ("tdaoff", handle_tdaoff (operand, errmsg));
+  CHECK_ ("hilo",   BFD_RELOC_32);
+
+  /* Restore skipped parenthesis.  */
+  if (paren_skipped)
+    --input_line_pointer;
+
+  return BFD_RELOC_NONE;
+}
+
+/* Insert an operand value into an instruction.  */
+
+static unsigned long
+v810_insert_operand (unsigned long insn,
+                     const struct v810_operand *operand,
+                     offsetT val,
+                     const char **errmsg)
+{
+  if (operand->insert)
+    {
+      const char *message = NULL;
+
+      insn = operand->insert (insn, val, &message);
+      if (message != NULL)
+        {
+          if ((operand->flags & V810_OPERAND_SIGNED)
+              && ! warn_signed_overflows
+              && v810_msg_is_out_of_range (message))
+            {
+              /* Skip warning...  */
+            }
+          else if ((operand->flags & V810_OPERAND_SIGNED) == 0
+                   && ! warn_unsigned_overflows
+                  && v810_msg_is_out_of_range (message))
+            {
+              /* Skip warning...  */
+            }
+          else
+            {
+             if (errmsg != NULL)
+               *errmsg = message;
+            }
+        }
+    }
+  else if (operand->bits == -1)
+    {
+      abort ();
+    }
+  else
+    {
+      if (operand->bits < 32)
+        {
+          long min, max;
+
+          if ((operand->flags & V810_OPERAND_SIGNED) != 0)
+            {
+              if (! warn_signed_overflows)
+                max = (1 << operand->bits) - 1;
+              else
+                max = (1 << (operand->bits - 1)) - 1;
+
+              min = -(1 << (operand->bits - 1));
+            }
+          else
+            {
+              max = (1 << operand->bits) - 1;
+
+              if (! warn_unsigned_overflows)
+                min = -(1 << (operand->bits - 1));
+              else
+                min = 0;
+            }
+
+          /* Some people write constants with the sign extension done by
+             hand but only up to 32 bits.  This shouldn't really be valid,
+             but, to permit this code to assemble on a 64-bit host, we
+             sign extend the 32-bit value to 64 bits if so doing makes the
+             value valid.  */
+          if (val > max
+              && (offsetT) (val - 0x80000000 - 0x80000000) >= min
+              && (offsetT) (val - 0x80000000 - 0x80000000) <= max)
+            val = val - 0x80000000 - 0x80000000;
+
+          /* Similarly, people write expressions like ~(1<<15), and expect
+             this to be OK for a 32-bit unsigned value.  */
+          else if (val < min
+                   && (offsetT) (val + 0x80000000 + 0x80000000) >= min
+                   && (offsetT) (val + 0x80000000 + 0x80000000) <= max)
+            val = val + 0x80000000 + 0x80000000;
+
+          else if (val < (offsetT) min || val > (offsetT) max)
+            {
+              static char buf [128];
+
+              /* Restore min and mix to expected values for decimal ranges.  */
+              if ((operand->flags & V810_OPERAND_SIGNED)
+                  && ! warn_signed_overflows)
+                max = (1 << (operand->bits - 1)) - 1;
+
+              if (! (operand->flags & V810_OPERAND_SIGNED)
+                  && ! warn_unsigned_overflows)
+                min = 0;
+
+              sprintf (buf, _("operand out of range (%d is not between %d and %d)"),
+                       (int) val, (int) min, (int) max);
+              *errmsg = buf;
+            }
+
+          insn |= (((long) val & ((1 << operand->bits) - 1)) << operand->shift);
+        }
+      else
+        {
+          insn |= (((long) val) << operand->shift);
+        }
+    }
+
+  return insn;
+}
+
+static char copy_of_instruction[128];
+
+void
+md_assemble (char *str)
+{
+  char *s;
+  char *start_of_operands;
+  struct v810_opcode *opcode;
+  struct v810_opcode *next_opcode;
+  const unsigned char *opindex_ptr;
+  int next_opindex;
+  int relaxable = 0;
+  unsigned long insn = 0;
+  unsigned long insn_size;
+  char *f = NULL;
+  int i;
+  int match;
+  bfd_boolean extra_data_after_insn = FALSE;
+  unsigned extra_data_len = 0;
+  unsigned long extra_data = 0;
+  char *saved_input_line_pointer;
+  char most_match_errmsg[1024];
+  int most_match_count = -1;
+
+  strncpy (copy_of_instruction, str, sizeof (copy_of_instruction) - 1);
+  most_match_errmsg[0] = 0;
+
+  /* Get the opcode.  */
+  for (s = str; *s != '\0' && ! ISSPACE (*s); s++)
+    continue;
+
+  if (*s != '\0')
+    *s++ = '\0';
+
+  /* Find the first opcode with the proper name.  */
+  opcode = (struct v810_opcode *) hash_find (v810_hash, str);
+  if (opcode == NULL)
+    {
+      /* xgettext:c-format  */
+      as_bad (_("Unrecognized opcode: `%s'"), str);
+      ignore_rest_of_line ();
+      return;
+    }
+
+  str = s;
+  while (ISSPACE (*str))
+    ++str;
+
+  start_of_operands = str;
+
+  saved_input_line_pointer = input_line_pointer;
+
+  for (;;)
+    {
+      const char *errmsg = NULL;
+      const char *warningmsg = NULL;
+
+      match = 0;
+      opindex_ptr = opcode->operands;
+
+      if ((opcode->processors & processor_mask & PROCESSOR_MASK) == 0
+          || (((opcode->processors & ~PROCESSOR_MASK) != 0)
+              && ((opcode->processors & processor_mask & ~PROCESSOR_MASK) == 0)))
+        {
+          errmsg = _("Target processor does not support this instruction.");
+          goto error;
+        }
+
+      relaxable = 0;
+      fc = 0;
+      next_opindex = 0;
+      insn = opcode->opcode;
+      extra_data_len = 0;
+      extra_data_after_insn = FALSE;
+
+      input_line_pointer = str = start_of_operands;
+
+      for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
+        {
+          const struct v810_operand *operand;
+          char *hold;
+          expressionS ex;
+          bfd_reloc_code_real_type reloc;
+
+          if (next_opindex == 0)
+            operand = &v810_operands[*opindex_ptr];
+          else
+            {
+              operand = &v810_operands[next_opindex];
+              next_opindex = 0;
+            }
+
+          errmsg = NULL;
+
+          while (*str == ' ')
+            ++str;
+
+          if (*str == ',' || *str == '[' || *str == ']')
+            ++str;
+
+          while (*str == ' ')
+            ++str;
+
+          if (operand->flags & V810_OPERAND_RELAX)
+            relaxable = 1;
+
+          /* Gather the operand.  */
+          hold = input_line_pointer;
+          input_line_pointer = str;
+
+          /* lo(), hi(), hi0(), etc...  */
+          if ((reloc = v810_reloc_prefix (operand, &errmsg)) != BFD_RELOC_NONE)
+            {
+              /* This is a fake reloc, used to indicate an error condition.  */
+              if (reloc == BFD_RELOC_64)
+                {
+                  /* match = 1;  */
+                  goto error;
+                }
+
+              expression (&ex);
+
+              if (ex.X_op == O_constant)
+                {
+                  switch (reloc)
+                    {
+                    case BFD_RELOC_V810_ZDA_16_16_OFFSET:
+                      /* To cope with "not1 7, zdaoff(0xfffff006)[r0]"
+                         and the like.  */
+                      /* Fall through.  */
+
+                    case BFD_RELOC_LO16:
+                      {
+                        /* Truncate, then sign extend the value.  */
+                        ex.X_add_number = SEXT16 (ex.X_add_number);
+                        break;
+                      }
+
+                    case BFD_RELOC_HI16:
+                      {
+                        /* Truncate, then sign extend the value.  */
+                        ex.X_add_number = SEXT16 (ex.X_add_number >> 16);
+                        break;
+                      }
+
+                    case BFD_RELOC_HI16_S:
+                      {
+                        /* Truncate, then sign extend the value.  */
+                        int temp = (ex.X_add_number >> 16) & 0xffff;
+
+                        temp += (ex.X_add_number >> 15) & 1;
+
+                        ex.X_add_number = SEXT16 (temp);
+                        break;
+                      }
+
+                    case BFD_RELOC_32:
+                        {
+                          errmsg = _("immediate operand is too large");
+                          goto error;
+                        }
+
+                      break;
+
+                    default:
+                      as_bad (_("AAARG -> unhandled constant reloc: %d"), reloc);
+                      break;
+                    }
+
+                  if (fc > MAX_INSN_FIXUPS)
+                    as_fatal (_("too many fixups"));
+
+                  fixups[fc].exp     = ex;
+                  fixups[fc].opindex = *opindex_ptr;
+                  fixups[fc].reloc   = reloc;
+                  fc++;
+                }
+              else      /* ex.X_op != O_constant.  */
+                {
+                  if ((reloc == BFD_RELOC_32)
+                      && operand->bits < 32)
+                    {
+                      errmsg = _("immediate operand is too large");
+                      goto error;
+                    }
+                  else if ((reloc == BFD_RELOC_HI16
+                            || reloc == BFD_RELOC_HI16_S)
+                           && operand->bits < 16)
+                    {
+                      errmsg = _("immediate operand is too large");
+                      goto error;
+                    }
+
+                  if (fc > MAX_INSN_FIXUPS)
+                    as_fatal (_("too many fixups"));
+
+                  fixups[fc].exp     = ex;
+                  fixups[fc].opindex = *opindex_ptr;
+                  fixups[fc].reloc   = reloc;
+                  fc++;
+                }
+            }
+          else
+            {
+              errmsg = NULL;
+
+              if ((operand->flags & V810_OPERAND_REG) != 0)
+                {
+                  if (!register_name (&ex))
+                    {
+                      errmsg = _("invalid register name");
+                    }
+                }
+              else if ((operand->flags & V810_OPERAND_SRG) != 0)
+                {
+                  if (!system_register_name (&ex, TRUE))
+                    {
+                      errmsg = _("invalid system register name");
+                    }
+                }
+              else if ((operand->flags & V810_OPERAND_CC) != 0)
+                {
+                  if (!cc_name (&ex, TRUE))
+                    {
+                      errmsg = _("invalid condition code name");
+                    }
+                }
+              else if ((register_name (&ex)
+                        && (operand->flags & V810_OPERAND_REG) == 0))
+                {
+		  char *name;
+		  char c;
+		  int exists = 0;
+
+		  /* It is possible that an alias has been defined that
+		     matches a register name.  For example the code may
+		     include a ".set ZERO, 0" directive, which matches
+		     the register name "zero".  Attempt to reparse the
+		     field as an expression, and only complain if we
+		     cannot generate a constant.  */
+
+		  input_line_pointer = str;
+
+		  c = get_symbol_name (&name);
+
+		  if (symbol_find (name) != NULL)
+		    exists = 1;
+
+		  (void) restore_line_pointer (c);
+		  input_line_pointer = str;
+
+		  expression (&ex);
+
+                  if (ex.X_op != O_constant)
+                    {
+                      /* If this register is actually occurring too early on
+                         the parsing of the instruction, (because another
+                         field is missing) then report this.  */
+                      if (opindex_ptr[1] != 0
+                          && ((v810_operands[opindex_ptr[1]].flags
+                               & V810_OPERAND_REG)))
+                        errmsg = _("syntax error: value is missing before the register name");
+                      else
+                        errmsg = _("syntax error: register not expected");
+
+                      /* If we created a symbol in the process of this
+                         test then delete it now, so that it will not
+                         be output with the real symbols...  */
+                      if (exists == 0
+                          && ex.X_op == O_symbol)
+                        symbol_remove (ex.X_add_symbol,
+                                       &symbol_rootP, &symbol_lastP);
+                    }
+                }
+              else if (system_register_name (&ex, FALSE)
+                       && (operand->flags & V810_OPERAND_SRG) == 0)
+                {
+                  errmsg = _("syntax error: system register not expected");
+                }
+              else if (cc_name (&ex, FALSE)
+                       && (operand->flags & V810_OPERAND_CC) == 0)
+                {
+                  errmsg = _("syntax error: condition code not expected");
+                }
+              else
+                {
+                  expression (&ex);
+
+                  /* JCB - Added conditional from old V810 patch.
+                     This may not be needed, but it doesn't seem to break stuff.  */
+                  if (ex.X_op == O_constant && (operand->flags & V810_OPERAND_DISP) != 0)
+                    {
+                      ex.X_add_symbol = &abs_symbol;
+                      ex.X_op = O_symbol;
+                      ex.X_op_symbol = NULL;
+                    }
+                }
+
+              if (errmsg)
+                goto error;
+
+              switch (ex.X_op)
+                {
+                case O_illegal:
+                  errmsg = _("illegal operand");
+                  goto error;
+                case O_absent:
+                  errmsg = _("missing operand");
+                  goto error;
+                case O_register:
+                  if ((operand->flags
+                       & (V810_OPERAND_REG | V810_OPERAND_SRG)) == 0)
+                    {
+                      errmsg = _("invalid operand");
+                      goto error;
+                    }
+
+                  insn = v810_insert_operand (insn, operand,
+                                              ex.X_add_number,
+                                              &warningmsg);
+
+                  break;
+
+                case O_constant:
+                  insn = v810_insert_operand (insn, operand, ex.X_add_number,
+                                              &warningmsg);
+                  break;
+
+                default:
+                  /* We need to generate a fixup for this expression.  */
+                  if (fc >= MAX_INSN_FIXUPS)
+                    as_fatal (_("too many fixups"));
+
+                  fixups[fc].exp     = ex;
+                  fixups[fc].opindex = *opindex_ptr;
+                  fixups[fc].reloc   = BFD_RELOC_NONE;
+                  ++fc;
+                  break;
+                }
+            }
+
+          str = input_line_pointer;
+          input_line_pointer = hold;
+
+          while (*str == ' ' || *str == ',' || *str == '[' || *str == ']'
+                 || *str == ')')
+            ++str;
+        }
+
+      while (ISSPACE (*str))
+        ++str;
+
+      if (*str == '\0')
+        match = 1;
+
+    error:
+      if (match == 0)
+        {
+          if ((opindex_ptr - opcode->operands) >= most_match_count)
+            {
+              most_match_count = opindex_ptr - opcode->operands;
+              if (errmsg != NULL)
+                strncpy (most_match_errmsg, errmsg, sizeof (most_match_errmsg)-1);
+            }
+
+          next_opcode = opcode + 1;
+          if (next_opcode->name != NULL
+              && strcmp (next_opcode->name, opcode->name) == 0)
+            {
+              opcode = next_opcode;
+
+              /* Skip versions that are not supported by the target
+                 processor.  */
+              if ((opcode->processors & processor_mask) == 0)
+                goto error;
+
+              continue;
+            }
+
+          if (most_match_errmsg[0] == 0)
+            /* xgettext:c-format.  */
+            as_bad (_("junk at end of line: `%s'"), str);
+          else
+            as_bad ("%s: %s", copy_of_instruction, most_match_errmsg);
+
+          if (*input_line_pointer == ']')
+            ++input_line_pointer;
+
+          ignore_rest_of_line ();
+          input_line_pointer = saved_input_line_pointer;
+          return;
+        }
+
+      if (warningmsg != NULL)
+        as_warn ("%s", warningmsg);
+      break;
+    }
+
+  input_line_pointer = str;
+
+  /* Tie dwarf2 debug info to the address at the start of the insn.
+     We can't do this after the insn has been output as the current
+     frag may have been closed off.  eg. by frag_var.  */
+  dwarf2_emit_insn (0);
+
+  /* Write out the instruction.  */
+
+  if (relaxable && fc > 0)
+    {
+      insn_size = 2;
+      fc = 0;
+
+      if (strcmp (opcode->name, "br") == 0
+          || strcmp (opcode->name, "jbr") == 0)
+        {
+              f = frag_var (rs_machine_dependent, 4, 2, SUBTYPE_UNCOND_9_26,
+                            fixups[0].exp.X_add_symbol,
+                            fixups[0].exp.X_add_number,
+                            (char *)(size_t) fixups[0].opindex);
+              md_number_to_chars (f, insn, insn_size);
+              md_number_to_chars (f + 2, 0, 2);
+        }
+      else /* b<cond>, j<cond>.  */
+        {
+                      f = frag_var (rs_machine_dependent, 6, 4, SUBTYPE_COND_9_26,
+                                    fixups[0].exp.X_add_symbol,
+                                    fixups[0].exp.X_add_number,
+                                    (char *)(size_t) fixups[0].opindex);
+                      md_number_to_chars (f, insn, insn_size);
+                      md_number_to_chars (f + 2, 0, 4);
+        }
+    }
+  else
+    {
+      /* Four byte insns have an opcode with the two high bits on.  */
+      if ((insn & 0xfc00) >= 0xa000)
+        insn_size = 4;
+      else
+        insn_size = 2;
+
+      if (obstack_room (& frchain_now->frch_obstack) < (insn_size + extra_data_len))
+        {
+          frag_wane (frag_now);
+          frag_new (0);
+        }
+
+      f = frag_more (insn_size);
+      md_number_to_chars (f, insn, insn_size);
+
+      if (extra_data_after_insn)
+        {
+          f = frag_more (extra_data_len);
+          md_number_to_chars (f, extra_data, extra_data_len);
+
+          extra_data_after_insn = FALSE;
+        }
+    }
+
+  /* Create any fixups.  At this point we do not use a
+     bfd_reloc_code_real_type, but instead just use the
+     BFD_RELOC_UNUSED plus the operand index.  This lets us easily
+     handle fixups for any operand type, although that is admittedly
+     not a very exciting feature.  We pick a BFD reloc type in
+     md_apply_fix.  */
+  for (i = 0; i < fc; i++)
+    {
+      const struct v810_operand *operand;
+      bfd_reloc_code_real_type reloc;
+
+      operand = &v810_operands[fixups[i].opindex];
+
+      reloc = fixups[i].reloc;
+
+      if (reloc != BFD_RELOC_NONE)
+        {
+          reloc_howto_type *reloc_howto =
+            bfd_reloc_type_lookup (stdoutput, reloc);
+          int size;
+          int address;
+          fixS *fixP;
+
+          if (!reloc_howto)
+            abort ();
+
+          size = bfd_get_reloc_size (reloc_howto);
+
+          /* XXX This will abort on an R_V810_8 reloc -
+             is this reloc actually used?  */
+          if (size != 2 && size != 4)
+            abort ();
+
+          if (extra_data_len == 0)
+            {
+              address = (f - frag_now->fr_literal) + insn_size - size;
+            }
+          else
+            {
+              address = (f - frag_now->fr_literal) + extra_data_len - size;
+            }
+
+          /* fprintf (stderr, "0x%x %d %ld\n", address, size, fixups[i].exp.X_add_number);  */
+          fixP = fix_new_exp (frag_now, address, size,
+                              &fixups[i].exp,
+                              reloc_howto->pc_relative,
+                              reloc);
+
+          fixP->tc_fix_data = (void *) operand;
+
+          switch (reloc)
+            {
+            case BFD_RELOC_LO16:
+            case BFD_RELOC_HI16:
+            case BFD_RELOC_HI16_S:
+              fixP->fx_no_overflow = 1;
+              break;
+            default:
+              break;
+            }
+        }
+      else
+        {
+          gas_assert (f != NULL);
+          fix_new_exp (frag_now,
+                       f - frag_now->fr_literal, 4,
+                       & fixups[i].exp,
+                       (operand->flags & V810_PCREL) != 0,
+                       (bfd_reloc_code_real_type) (fixups[i].opindex
+                                                   + (int) BFD_RELOC_UNUSED));
+        }
+    }
+
+  input_line_pointer = saved_input_line_pointer;
+}
+
+/* If while processing a fixup, a reloc really needs to be created
+   then it is done here.  */
+
+arelent *
+tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
+{
+  arelent *reloc;
+
+  reloc               = XNEW (arelent);
+  reloc->sym_ptr_ptr  = XNEW (asymbol *);
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address      = fixp->fx_frag->fr_address + fixp->fx_where;
+
+  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
+      || fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixp->fx_r_type == BFD_RELOC_V810_ALIGN)
+    reloc->addend = fixp->fx_offset;
+  else
+    {
+#if 0
+      if (fixp->fx_r_type == BFD_RELOC_32
+          && fixp->fx_pcrel)
+        fixp->fx_r_type = BFD_RELOC_32_PCREL;
+#endif
+
+      reloc->addend = fixp->fx_addnumber;
+    }
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+                    /* xgettext:c-format  */
+                    _("reloc %d not supported by object file format"),
+                    (int) fixp->fx_r_type);
+
+      xfree (reloc);
+
+      return NULL;
+    }
+
+  return reloc;
+}
+
+void
+v810_handle_align (fragS * frag)
+{
+  if (v810_relax
+      && frag->fr_type == rs_align
+      && frag->fr_address + frag->fr_fix > 0
+      && frag->fr_offset > 1
+      && now_seg != bss_section
+      && now_seg != v810_seg_table[SBSS_SECTION].s
+      && now_seg != v810_seg_table[TBSS_SECTION].s
+      && now_seg != v810_seg_table[ZBSS_SECTION].s)
+    fix_new (frag, frag->fr_fix, 2, & abs_symbol, frag->fr_offset, 0,
+             BFD_RELOC_V810_ALIGN);
+}
+
+/* Return current size of variable part of frag.  */
+
+int
+md_estimate_size_before_relax (fragS *fragp, asection *seg ATTRIBUTE_UNUSED)
+{
+  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
+    abort ();
+
+  return md_relax_table[fragp->fr_subtype].rlx_length;
+}
+
+long
+v810_pcrel_from_section (fixS *fixp, segT section)
+{
+  /* If the symbol is undefined, or in a section other than our own,
+     or it is weak (in which case it may well be in another section,
+     then let the linker figure it out.  */
+  if (fixp->fx_addsy != (symbolS *) NULL
+      && (! S_IS_DEFINED (fixp->fx_addsy)
+          || S_IS_WEAK (fixp->fx_addsy)
+          || (S_GET_SEGMENT (fixp->fx_addsy) != section)))
+    return 0;
+
+  return fixp->fx_frag->fr_address + fixp->fx_where;
+}
+
+void
+md_apply_fix (fixS *fixP, valueT *valueP, segT seg ATTRIBUTE_UNUSED)
+{
+  valueT value = * valueP;
+  char *where;
+
+  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    {
+      fixP->fx_done = 0;
+      return;
+    }
+
+  if (fixP->fx_addsy == (symbolS *) NULL)
+    fixP->fx_addnumber = value,
+    fixP->fx_done = 1;
+
+  else if (fixP->fx_pcrel)
+    fixP->fx_addnumber = fixP->fx_offset;
+
+  else
+    {
+      value = fixP->fx_offset;
+      if (fixP->fx_subsy != (symbolS *) NULL)
+        {
+          if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
+            value -= S_GET_VALUE (fixP->fx_subsy);
+          else
+            /* We don't actually support subtracting a symbol.  */
+            as_bad_where (fixP->fx_file, fixP->fx_line,
+                          _("expression too complex"));
+        }
+      fixP->fx_addnumber = value;
+    }
+
+  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
+    {
+      int opindex;
+      const struct v810_operand *operand;
+      unsigned long insn;
+      const char *errmsg = NULL;
+
+      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
+      operand = &v810_operands[opindex];
+
+      /* Fetch the instruction, insert the fully resolved operand
+         value, and stuff the instruction back again.
+
+         Note the instruction has been stored in little endian
+         format!  */
+      where = fixP->fx_frag->fr_literal + fixP->fx_where;
+
+      if (fixP->fx_size > 2)
+        insn = bfd_getl32 ((unsigned char *) where);
+      else
+        insn = bfd_getl16 ((unsigned char *) where);
+
+      insn = v810_insert_operand (insn, operand, (offsetT) value,
+                                  &errmsg);
+      if (errmsg)
+        as_warn_where (fixP->fx_file, fixP->fx_line, "%s", errmsg);
+
+      if (fixP->fx_size > 2)
+        bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
+      else
+        bfd_putl16 ((bfd_vma) insn, (unsigned char *) where);
+
+      if (fixP->fx_done)
+        /* Nothing else to do here.  */
+        return;
+
+      /* Determine a BFD reloc value based on the operand information.
+         We are only prepared to turn a few of the operands into relocs.  */
+
+      if (operand->default_reloc == BFD_RELOC_NONE)
+        {
+          as_bad_where (fixP->fx_file, fixP->fx_line,
+                        _("unresolved expression that must be resolved"));
+          fixP->fx_done = 1;
+          return;
+        }
+
+      {
+        fixP->fx_r_type = operand->default_reloc;
+      }
+    }
+  else if (fixP->fx_done)
+    {
+      /* We still have to insert the value into memory!  */
+      where = fixP->fx_frag->fr_literal + fixP->fx_where;
+
+      if (fixP->tc_fix_data != NULL
+          && ((struct v810_operand *) fixP->tc_fix_data)->insert != NULL)
+        {
+          const char * message = NULL;
+          struct v810_operand * operand = (struct v810_operand *) fixP->tc_fix_data;
+          unsigned long insn;
+
+          /* The variable "where" currently points at the exact point inside
+             the insn where we need to insert the value.  But we need to
+             extract the entire insn so we probably need to move "where"
+             back a few bytes.  */
+
+          if (fixP->fx_size == 2)
+            where -= 2;
+          else if (fixP->fx_size == 1)
+            where -= 3;
+
+          insn = bfd_getl32 ((unsigned char *) where);
+
+          /* Use the operand's insertion procedure, if present, in order to
+             make sure that the value is correctly stored in the insn.  */
+          insn = operand->insert (insn, (offsetT) value, & message);
+          /* Ignore message even if it is set.  */
+
+          bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
+        }
+      else
+        {
+          switch (fixP->fx_r_type)
+            {
+            case BFD_RELOC_32:
+              bfd_putl32 (value, (unsigned char *) where);
+              break;
+
+            case BFD_RELOC_16:
+            case BFD_RELOC_HI16:
+            case BFD_RELOC_HI16_S:
+            case BFD_RELOC_LO16:
+            case BFD_RELOC_V810_ZDA_16_16_OFFSET:
+            case BFD_RELOC_V810_SDA_16_16_OFFSET:
+            case BFD_RELOC_V810_TDA_16_16_OFFSET:
+              bfd_putl16 (value & 0xffff, (unsigned char *) where);
+              break;
+
+            case BFD_RELOC_8:
+              *where = value & 0xff;
+              break;
+
+            case BFD_RELOC_V810_9_PCREL:
+              bfd_putl16 (((value & 0x1f0) << 7) | ((value & 0x0e) << 3)
+                          | (bfd_getl16 (where) & ~((0x1f0 << 7) | (0x0e << 3))), where);
+              break;
+
+            case BFD_RELOC_V810_26_PCREL:
+              bfd_putl32 (((value & 0xfffe) << 16) | ((value & 0x3ff0000) >> 16)
+                          | (bfd_getl32 (where) & ~((0xfffe << 16) | (0x3ff0000 >> 16))), where);
+              break;
+
+            default:
+              abort ();
+            }
+        }
+    }
+}
+
+/* Parse a cons expression.  We have to handle hi(), lo(), etc
+   on the v810.  */
+
+bfd_reloc_code_real_type
+parse_cons_expression_v810 (expressionS *exp)
+{
+  const char *errmsg;
+  bfd_reloc_code_real_type r;
+
+  /* See if there's a reloc prefix like hi() we have to handle.  */
+  r = v810_reloc_prefix (NULL, &errmsg);
+
+  /* Do normal expression parsing.  */
+  expression (exp);
+  return r;
+}
+
+/* Create a fixup for a cons expression.  If parse_cons_expression_v810
+   found a reloc prefix, then we use that reloc, else we choose an
+   appropriate one based on the size of the expression.  */
+
+void
+cons_fix_new_v810 (fragS *frag,
+		   int where,
+		   int size,
+		   expressionS *exp,
+		   bfd_reloc_code_real_type r)
+{
+  if (r == BFD_RELOC_NONE)
+    {
+      if (size == 4)
+        r = BFD_RELOC_32;
+      if (size == 2)
+        r = BFD_RELOC_16;
+      if (size == 1)
+        r = BFD_RELOC_8;
+    }
+
+  if (exp != NULL)
+    fix_new_exp (frag, where, size, exp, 0, r);
+  else
+    fix_new (frag, where, size, NULL, 0, 0, r);
+}
+
+bfd_boolean
+v810_fix_adjustable (fixS *fixP)
+{
+  if (fixP->fx_addsy == NULL)
+    return 1;
+
+  /* Don't adjust function names.  */
+  if (S_IS_FUNCTION (fixP->fx_addsy))
+    return 0;
+
+  /* We need the symbol name for the VTABLE entries.  */
+  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return 0;
+
+  return 1;
+}
+
+int
+v810_force_relocation (struct fix *fixP)
+{
+  if (v810_relax
+      && (fixP->fx_pcrel
+          || fixP->fx_r_type == BFD_RELOC_V810_ALIGN
+          || fixP->fx_r_type == BFD_RELOC_V810_9_PCREL
+          || fixP->fx_r_type == BFD_RELOC_V810_26_PCREL
+          || fixP->fx_r_type >= BFD_RELOC_UNUSED))
+    return 1;
+
+  return generic_force_reloc (fixP);
+}
diff -Naur binutils-2.27-pure/gas/config/tc-v810.h binutils-2.27/gas/config/tc-v810.h
--- binutils-2.27-pure/gas/config/tc-v810.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/config/tc-v810.h	2022-02-10 13:50:25.764361300 -0500
@@ -0,0 +1,84 @@
+/* tc-v810.h -- Header file for tc-v810.c.
+   Copyright (C) 1996-2016 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#define TC_V810
+
+#include "elf/v810.h"
+
+#define TARGET_BYTES_BIG_ENDIAN 0
+
+/* The target BFD architecture.  */
+#define TARGET_ARCH             bfd_arch_v810
+
+/* The target BFD format.  */
+#define TARGET_FORMAT           "elf32-v810"
+
+#define md_operand(x)
+
+#define tc_fix_adjustable(FIX) v810_fix_adjustable (FIX)
+extern bfd_boolean v810_fix_adjustable (struct fix *);
+
+#define TC_FORCE_RELOCATION(FIX) v810_force_relocation(FIX)
+extern int v810_force_relocation (struct fix *);
+
+#ifdef OBJ_ELF
+/* Values passed to md_apply_fix don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+#endif
+
+/* Permit temporary numeric labels.  */
+#define LOCAL_LABELS_FB 1
+
+#define DIFF_EXPR_OK            /* foo-. gets turned into PC relative relocs.  */
+
+/* We don't need to handle .word strangely.  */
+#define WORKING_DOT_WORD
+
+#define md_number_to_chars number_to_chars_littleendian
+
+/* We need to handle lo(), hi(), etc etc in .hword, .word, etc
+   directives, so we have to parse "cons" expressions ourselves.  */
+#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) parse_cons_expression_v810 (EXP)
+extern bfd_reloc_code_real_type parse_cons_expression_v810 (expressionS *);
+
+#define TC_CONS_FIX_NEW cons_fix_new_v810
+extern void cons_fix_new_v810 (fragS *, int, int, expressionS *,
+			       bfd_reloc_code_real_type);
+
+#define TC_GENERIC_RELAX_TABLE md_relax_table
+extern const struct relax_type md_relax_table[];
+
+/* When relaxing, we need to generate
+   relocations for alignment directives.  */
+#define HANDLE_ALIGN(frag) v810_handle_align (frag)
+extern void v810_handle_align (fragS *);
+
+/* We need space in a frag's fixed size to allow for alignment when relaxing.  */
+#define TC_FX_SIZE_SLACK(FIX) 2
+
+#define MD_PCREL_FROM_SECTION(FIX, SEC) v810_pcrel_from_section (FIX, SEC)
+extern long v810_pcrel_from_section (struct fix *, asection *);
+
+#define DWARF2_LINE_MIN_INSN_LENGTH 2
+
+/* We need to record the operand involved when a pseudo-reloc is
+   processed so that the resulting value can be inserted correctly.  */
+#define TC_FIX_TYPE             void *
+#define TC_INIT_FIX_DATA(fixP)  (fixP)->tc_fix_data = NULL
diff -Naur binutils-2.27-pure/gas/configure.tgt binutils-2.27/gas/configure.tgt
--- binutils-2.27-pure/gas/configure.tgt	2016-08-03 03:36:51.000000000 -0400
+++ binutils-2.27/gas/configure.tgt	2022-02-10 13:50:25.777362000 -0500
@@ -107,6 +107,7 @@
   sparc*)		cpu_type=sparc arch=sparclite ;; # ??? See tc-sparc.c.
   tilegx*be)		cpu_type=tilegx endian=big ;;
   tilegx*)		cpu_type=tilegx endian=little ;;
+  v810*)		cpu_type=v810 ;;
   v850*)		cpu_type=v850 ;;
   visium)		cpu_type=visium endian=big ;;
   x86_64*)		cpu_type=i386 arch=x86_64;;
@@ -455,6 +456,7 @@
 
   tilepro-*-* | tilegx*-*-*)		fmt=elf ;;
 
+  v810*-*-*)				fmt=elf ;;
   v850*-*-*)				fmt=elf ;;
 
   vax-*-netbsdelf*)			fmt=elf em=nbsd ;;
diff -Naur binutils-2.27-pure/gas/doc/c-v810.texi binutils-2.27/gas/doc/c-v810.texi
--- binutils-2.27-pure/gas/doc/c-v810.texi	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/doc/c-v810.texi	2022-02-10 13:50:25.789362700 -0500
@@ -0,0 +1,347 @@
+@c Copyright (C) 1997-2016 Free Software Foundation, Inc.
+@c This is part of the GAS manual.
+@c For copying conditions, see the file as.texinfo.
+
+@node V810-Dependent
+@chapter v810 Dependent Features
+
+@cindex V810 support
+@menu
+* V810 Options::              Options
+* V810 Syntax::               Syntax
+* V810 Floating Point::       Floating Point
+* V810 Directives::           V810 Machine Directives
+* V810 Opcodes::              Opcodes
+@end menu
+
+@node V810 Options
+@section Options
+@cindex V810 options (none)
+@cindex options for V810 (none)
+@code{@value{AS}} supports the following additional command-line options
+for the V810 processor family:
+
+@cindex command line options, V810
+@cindex V810 command line options
+@table @code
+
+@cindex @code{-wsigned_overflow} command line option, V810
+@item -wsigned_overflow
+Causes warnings to be produced when signed immediate values overflow the
+space available for then within their opcodes.  By default this option
+is disabled as it is possible to receive spurious warnings due to using
+exact bit patterns as immediate constants.
+
+@cindex @code{-wunsigned_overflow} command line option, V810
+@item -wunsigned_overflow
+Causes warnings to be produced when unsigned immediate values overflow
+the space available for then within their opcodes.  By default this
+option is disabled as it is possible to receive spurious warnings due to
+using exact bit patterns as immediate constants.
+
+@cindex @code{-mv810} command line option, V810
+@item -mv810
+Specifies that the assembled code should be marked as being targeted at
+the V810 processor.  This allows the linker to detect attempts to link
+such code with code assembled for other processors.
+
+@cindex @code{-mrelax} command line option, V810
+@item -mrelax
+Enables relaxation.  This allows the .longcall and .longjump pseudo
+ops to be used in the assembler source code.  These ops label sections
+of code which are either a long function call or a long branch.  The
+assembler will then flag these sections of code and the linker will
+attempt to relax them.
+
+@end table
+
+
+@node V810 Syntax
+@section Syntax
+@menu
+* V810-Chars::                Special Characters
+* V810-Regs::                 Register Names
+@end menu
+
+@node V810-Chars
+@subsection Special Characters
+
+@cindex line comment character, V810
+@cindex V810 line comment character
+@samp{#} is the line comment character.  If a @samp{#} appears as the
+first character of a line, the whole line is treated as a comment, but
+in this case the line can also be a logical line number directive
+(@pxref{Comments}) or a preprocessor control command
+(@pxref{Preprocessing}).
+
+Two dashes (@samp{--}) can also be used to start a line comment.
+
+@cindex line separator, V810
+@cindex statement separator, V810
+@cindex V810 line separator
+
+The @samp{;} character can be used to separate statements on the same
+line.
+
+@node V810-Regs
+@subsection Register Names
+
+@cindex V810 register names
+@cindex register names, V810
+@code{@value{AS}} supports the following names for registers:
+@table @code
+@cindex @code{zero} register, V810
+@item general register 0
+r0, zero
+@item general register 1
+r1
+@item general register 2
+r2, fp
+@cindex @code{sp} register, V810
+@item general register 3
+r3, sp
+@cindex @code{gp} register, V810
+@item general register 4
+r4, gp
+@cindex @code{tp} register, V810
+@item general register 5
+r5, tp
+@item general register 6
+r6
+@item general register 7
+r7
+@item general register 8
+r8
+@item general register 9
+r9
+@item general register 10
+r10
+@item general register 11
+r11
+@item general register 12
+r12
+@item general register 13
+r13
+@item general register 14
+r14
+@item general register 15
+r15
+@item general register 16
+r16
+@item general register 17
+r17
+@item general register 18
+r18
+@item general register 19
+r19
+@item general register 20
+r20
+@item general register 21
+r21
+@item general register 22
+r22
+@item general register 23
+r23
+@item general register 24
+r24
+@item general register 25
+r25
+@item general register 26
+r26
+@item general register 27
+r27
+@item general register 28
+r28
+@item general register 29
+r29
+@item general register 30
+r30
+@cindex @code{lp} register, V810
+@item general register 31
+r31, lp
+@cindex @code{eipc} register, V810
+@item system register 0
+eipc
+@cindex @code{eipsw} register, V810
+@item system register 1
+eipsw
+@cindex @code{fepc} register, V810
+@item system register 2
+fepc
+@cindex @code{fepsw} register, V810
+@item system register 3
+fepsw
+@cindex @code{ecr} register, V810
+@item system register 4
+ecr
+@cindex @code{psw} register, V810
+@item system register 5
+psw
+@cindex @code{ctpc} register, V810
+@item system register 16
+ctpc
+@cindex @code{ctpsw} register, V810
+@item system register 17
+ctpsw
+@cindex @code{dbpc} register, V810
+@item system register 18
+dbpc
+@cindex @code{dbpsw} register, V810
+@item system register 19
+dbpsw
+@cindex @code{ctbp} register, V810
+@item system register 20
+ctbp
+@end table
+
+@node V810 Floating Point
+@section Floating Point
+
+@cindex floating point, V810 (@sc{ieee})
+@cindex V810 floating point (@sc{ieee})
+The V810 family uses @sc{ieee} floating-point numbers.
+
+@node V810 Directives
+@section V810 Machine Directives
+
+@cindex machine directives, V810
+@cindex V810 machine directives
+@table @code
+@cindex @code{offset} directive, V810
+@item .offset @var{<expression>}
+Moves the offset into the current section to the specified amount. 
+
+@cindex @code{section} directive, V810
+@item .section "name", <type>
+This is an extension to the standard .section directive.  It sets the
+current section to be <type> and creates an alias for this section
+called "name". 
+
+@cindex @code{.v810} directive, V810
+@item .v810
+Specifies that the assembled code should be marked as being targeted at
+the V810 processor.  This allows the linker to detect attempts to link
+such code with code assembled for other processors.
+
+@end table
+
+@node V810 Opcodes
+@section Opcodes
+
+@cindex V810 opcodes
+@cindex opcodes for V810
+@code{@value{AS}} implements all the standard V810 opcodes.
+
+@code{@value{AS}} also implements the following pseudo ops:
+
+@table @code
+
+@cindex @code{hi0} pseudo-op, V810
+@item hi0()
+Computes the higher 16 bits of the given expression and stores it into
+the immediate operand field of the given instruction.  For example:
+
+    @samp{mulhi hi0(here - there), r5, r6}
+
+computes the difference between the address of labels 'here' and
+'there', takes the upper 16 bits of this difference, shifts it down 16
+bits and then multiplies it by the lower 16 bits in register 5, putting
+the result into register 6. 
+
+@cindex @code{lo} pseudo-op, V810
+@item lo()
+Computes the lower 16 bits of the given expression and stores it into
+the immediate operand field of the given instruction.  For example:
+
+    @samp{addi lo(here - there), r5, r6}
+
+computes the difference between the address of labels 'here' and
+'there', takes the lower 16 bits of this difference and adds it to
+register 5, putting the result into register 6.
+
+@cindex @code{hi} pseudo-op, V810
+@item hi()
+Computes the higher 16 bits of the given expression and then adds the
+value of the most significant bit of the lower 16 bits of the expression
+and stores the result into the immediate operand field of the given
+instruction.  For example the following code can be used to compute the
+address of the label 'here' and store it into register 6:
+
+    @samp{movhi hi(here), r0, r6}
+    @samp{movea lo(here), r6, r6}
+
+The reason for this special behaviour is that movea performs a sign
+extension on its immediate operand.  So for example if the address of
+'here' was 0xFFFFFFFF then without the special behaviour of the hi()
+pseudo-op the movhi instruction would put 0xFFFF0000 into r6, then the
+movea instruction would takes its immediate operand, 0xFFFF, sign extend
+it to 32 bits, 0xFFFFFFFF, and then add it into r6 giving 0xFFFEFFFF
+which is wrong (the fifth nibble is E).  With the hi() pseudo op adding
+in the top bit of the lo() pseudo op, the movhi instruction actually
+stores 0 into r6 (0xFFFF + 1 = 0x0000), so that the movea instruction
+stores 0xFFFFFFFF into r6 - the right value.
+
+@cindex @code{hilo} pseudo-op, V810
+@item hilo()
+Computes the 32 bit value of the given expression and stores it into
+the immediate operand field of the given instruction (which must be a
+mov instruction).  For example:
+
+    @samp{mov hilo(here), r6}
+
+computes the absolute address of label 'here' and puts the result into
+register 6.  
+
+@cindex @code{sdaoff} pseudo-op, V810
+@item sdaoff()
+Computes the offset of the named variable from the start of the Small
+Data Area (whoes address is held in register 4, the GP register) and
+stores the result as a 16 bit signed value in the immediate operand
+field of the given instruction.  For example: 
+
+      @samp{ld.w sdaoff(_a_variable)[gp],r6}
+
+loads the contents of the location pointed to by the label '_a_variable'
+into register 6, provided that the label is located somewhere within +/-
+32K of the address held in the GP register.  [Note the linker assumes
+that the GP register contains a fixed address set to the address of the
+label called '__gp'.  This can either be set up automatically by the
+linker, or specifically set by using the @samp{--defsym __gp=<value>}
+command line option].
+
+@cindex @code{tdaoff} pseudo-op, V810
+@item tdaoff()
+Computes the offset of the named variable from the start of the Thread
+Data Area (whoes address is held in register 5, the TP register) and
+stores the result as a 16 bit signed value in the immediate operand
+field of the given instruction.  For example: 
+
+      @samp{sld.w tdaoff(_a_variable)[tp],r6}
+
+loads the contents of the location pointed to by the label '_a_variable'
+into register 6, provided that the label is located somewhere within
+32K of the address held in the TP register.  [Note the linker assumes
+that the TP register contains a fixed address set to the address of the
+label called '__tp'.  This can either be set up automatically by the
+linker, or specifically set by using the @samp{--defsym __tp=<value>}
+command line option].
+
+@cindex @code{zdaoff} pseudo-op, V810
+@item zdaoff()
+Computes the offset of the named variable from address 0 and stores the
+result as a 16 bit signed value in the immediate operand field of the
+given instruction.  For example:
+
+      @samp{movea zdaoff(_a_variable),zero,r6}
+
+puts the address of the label '_a_variable' into register 6, assuming
+that the label is somewhere within the first 32K of memory.  (Strictly
+speaking it also possible to access the last 32K of memory as well, as
+the offsets are signed).
+
+@end table
+
+
+For information on the V810 instruction set, see @cite{V810
+Family 32-/16-Bit single-Chip Microcontroller Architecture Manual} from NEC.
+Ltd.
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/arith.s binutils-2.27/gas/testsuite/gas/v810/arith.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/arith.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/arith.s	2022-02-10 13:50:25.798363300 -0500
@@ -0,0 +1,16 @@
+
+	.text
+	.global arith_opcodes
+arith_opcodes:
+	add r5,r6
+	add 5,r6
+	addi 7,r5,r6
+	div r5,r6
+	mul r5,r6
+	sar r5,r6
+	sar 31,r6
+	shl r5,r6
+	shl 31,r6
+	shr r5,r6
+	shr 31,r6
+	sub r5,r6
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/basic.exp binutils-2.27/gas/testsuite/gas/v810/basic.exp
--- binutils-2.27-pure/gas/testsuite/gas/v810/basic.exp	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/basic.exp	2022-02-10 13:50:25.811364000 -0500
@@ -0,0 +1,467 @@
+# Copyright (C) 1996-2016 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+# Please email any bugs, comments, and/or additions to this file to:
+# dejagnu@gnu.org
+
+# Written by Cygnus Support.
+
+proc do_arith {} {
+    set testname "arith.s: Arithmetic operations"
+    set x 0
+
+    gas_start "arith.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    # -re "^ +\[0-9\]+ 0000 489A0000\[^\n\]*\n"	{ set x [expr $x+1] }
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 C504\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 C544\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 C5A40700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 C524\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000a C520\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c C51C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000e DF5C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 C510\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0012 DF50\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0014 C514\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0016 DF54\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0018 C508\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==12] then { pass $testname } else { fail $testname }
+}
+
+proc do_branch {} {
+    set testname "branch.s: branch operations"
+    set x 0
+
+    gas_start "branch.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 009E\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 FE9D\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 FC8D\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0006 FA8F\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 F897\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000a F693\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c F483\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000e F287\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 F085\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0012 EE95\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0014 EC81\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0016 EA91\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0018 E889\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001a E699\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001c E483\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001e E293\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0020 E085\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0022 DE95\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0024 DC8B\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==19] then { pass $testname } else { fail $testname }
+}
+
+proc do_compare {} {
+    set testname "compare.s: compare operations"
+    set x 0
+
+    gas_start "compare.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 C50C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 C54C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 A048\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0006 A848\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 A148\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000a A148\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c A948\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000e A948\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 A248\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0012 AA48\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0014 A348\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0016 AB48\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0018 A448\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001a A448\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001c AC48\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001e AC48\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0020 A548\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0022 A648\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0024 AE48\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0026 A748\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0028 AF48\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==21] then { pass $testname } else { fail $testname }
+}
+
+proc do_jumps {} {
+    set testname "jumps.s: jumps operations"
+    set x 0
+
+    gas_start "jumps.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 00AC0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 0518\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0006 1F18\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 FFABF8FF\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==4] then { pass $testname } else { fail $testname }
+}
+
+proc do_logical {} {
+    set testname "logical.s: logical operations"
+    set x 0
+
+    gas_start "logical.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 C534\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 C5B40700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0006 C53C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 C530\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000a C5B00700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000e C538\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 C5B80700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==7] then { pass $testname } else { fail $testname }
+}
+
+proc do_mem {} {
+    set testname "mem.s: memory operations"
+    set x 0
+
+    gas_start "mem.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 C5C00500\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 C5C40400\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 C5CC0400\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c C4CC0400\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 E3CF0400\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0014 A6D00500\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0018 A6D40400\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001c A6DC0400\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0020 A4DC0400\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0024 E3DF0400\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==10] then { pass $testname } else { fail $testname }
+}
+
+proc do_misc {} {
+    set testname "misc.s: misc operations"
+    set x 0
+
+    gas_start "misc.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 0068\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 009A\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 0064\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0006 0060\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 1F60\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000a E570\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c E574\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==7] then { pass $testname } else { fail $testname }
+}
+
+proc do_move {} {
+    set testname "move.s: move operations"
+    set x 0
+
+    gas_start "move.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 C500\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 C540\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 C5A00700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 C5BC0700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==4] then { pass $testname } else { fail $testname }
+}
+
+proc do_hilo {} {
+    set testname "hilo.s: hilo tests"
+    set x 0
+
+    gas_start "hilo.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 20A0EFBE\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 21BCAEDE\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 21BCADDE\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==3] then { pass $testname } else { fail $testname }
+}
+
+proc do_float {} {
+    set testname "float.s: Floating point operations"
+    set x 0
+
+    gas_start "float.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    # -re "^ +\[0-9\]+ 0000 489A0000\[^\n\]*\n"	{ set x [expr $x+1] }
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 C5F80000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 C5F80008\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 C5F8000C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c C5F80010\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 C5F80014\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0014 C5F80018\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0018 C5F8001C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001c C5F8002C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==8] then { pass $testname } else { fail $testname }
+}
+
+proc do_bitstring {} {
+    set testname "bitstring.s: Bit string operations"
+    set x 0
+
+    gas_start "bitstring.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    # -re "^ +\[0-9\]+ 0000 489A0000\[^\n\]*\n"	{ set x [expr $x+1] }
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 007C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 017C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 027C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0006 037C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 087C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000a 097C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c 0A7C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000e 0B7C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 0C7C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0012 0D7C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0014 0E7C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0016 0F7C\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==12] then { pass $testname } else { fail $testname }
+}
+
+proc do_simple_reloc_tests {} {
+    set testname "reloc.s: Test for proper relocations (part 2)"
+    set x 0
+
+    if [gas_test_old "reloc.s" "" "Test for proper relocation (part 1)"] then {
+	objdump_start_no_subdir "a.out" "-r"
+
+	while 1 {
+	    expect {
+		-re "^00000002\[^\n\]*R_V810_LO16\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "^00000006\[^\n\]*R_V810_HI16_S\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "^0000000a\[^\n\]*R_V810_HI16\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "^0000000e\[^\n\]*R_V810_ZDA_16_16_OFFSET\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "^00000012\[^\n\]*R_V810_SDA_16_16_OFFSET\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "\[^\n\]*\n"				{ }
+		timeout			{ perror "timeout\n"; break }
+		eof				{ break }
+	    }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    objdump_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==5] then { pass $testname } else { fail $testname }
+}
+
+if [istarget v810*-*-*] then {
+    # Test the basic instruction parser.
+    do_arith
+    do_branch
+    do_compare
+    do_jumps
+    do_logical
+    do_mem
+    do_misc
+    do_move
+
+    # Make sure we handle lo() hi() and hi0() correctly.
+    do_hilo
+
+    # Check for proper relocs on lo, hi, hi0, zdaoff, tdaoff and sdaoff
+    # expressions
+    do_simple_reloc_tests
+
+    # Check V810-only instructions.
+    do_float
+    do_bitstring
+
+    gas_test "hilo2.s" "" "" "hi/lo regression test"
+    gas_test "fepsw.s" "" "" "eqsw regression test"
+
+    gas_test_error "range.s" "-mwarn-signed-overflow" "Check for range error on byte load/store"
+}
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/bitstring.s binutils-2.27/gas/testsuite/gas/v810/bitstring.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/bitstring.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/bitstring.s	2022-02-10 13:50:25.819364500 -0500
@@ -0,0 +1,17 @@
+
+	.v810
+	.text
+	.global v810_string
+v810_string:
+	sch0bsu
+	sch0bsd
+	sch1bsu
+	sch1bsd
+	orbsu
+	andbsu
+	xorbsu
+	movbsu
+	ornbsu
+	andnbsu
+	xornbsu
+	notbsu
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/branch.s binutils-2.27/gas/testsuite/gas/v810/branch.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/branch.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/branch.s	2022-02-10 13:50:25.827364900 -0500
@@ -0,0 +1,23 @@
+
+	.text
+	.global bcc
+bcc:
+	bgt bcc
+	bge bcc
+	blt bcc
+	ble bcc
+	bh bcc
+	bnl bcc
+	bl bcc
+	bnh bcc
+	be bcc
+	bne bcc
+	bv bcc
+	bnv bcc
+	bn bcc
+	bp bcc
+	bc bcc
+	bnc bcc
+	bz bcc
+	bnz bcc
+	br bcc
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/compare.s binutils-2.27/gas/testsuite/gas/v810/compare.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/compare.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/compare.s	2022-02-10 13:50:25.835365400 -0500
@@ -0,0 +1,26 @@
+
+	.text
+	.global compare
+compare:
+	cmp r5,r6
+	cmp 5,r6
+	setf v,r5
+	setf nv,r5
+	setf c,r5
+	setf l,r5
+	setf nc,r5
+	setf nl,r5
+	setf z,r5
+	setf nz,r5
+	setf nh,r5
+	setf h,r5
+	setf s,r5
+	setf n,r5
+	setf ns,r5
+	setf p,r5
+	setf t,r5
+	setf lt,r5
+	setf ge,r5
+	setf le,r5
+	setf gt,r5
+	
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/fepsw.s binutils-2.27/gas/testsuite/gas/v810/fepsw.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/fepsw.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/fepsw.s	2022-02-10 13:50:25.842365800 -0500
@@ -0,0 +1,2 @@
+	.text
+	ldsr r17,fepsw
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/float.s binutils-2.27/gas/testsuite/gas/v810/float.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/float.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/float.s	2022-02-10 13:50:25.850366200 -0500
@@ -0,0 +1,13 @@
+
+	.v810
+	.text
+	.global v810_float
+v810_float:
+	cmpf.s r5,r6
+	cvt.ws r5,r6
+	cvt.sw r5,r6
+	addf.s r5,r6
+	subf.s r5,r6
+	mulf.s r5,r6
+	divf.s r5,r6
+	trnc.sw r5,r6
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/hilo.s binutils-2.27/gas/testsuite/gas/v810/hilo.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/hilo.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/hilo.s	2022-02-10 13:50:25.858366700 -0500
@@ -0,0 +1,5 @@
+
+	.text
+	movea lo(0xdeadbeef),r0,r1
+	movhi hi(0xdeadbeef),r1,r1
+	movhi hi0(0xdeadbeef),r1,r1
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/hilo2.s binutils-2.27/gas/testsuite/gas/v810/hilo2.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/hilo2.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/hilo2.s	2022-02-10 13:50:25.865367100 -0500
@@ -0,0 +1,4 @@
+	.text
+	.org 0x10000
+	movea hi(blah),r0,r1
+blah:
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/jumps.s binutils-2.27/gas/testsuite/gas/v810/jumps.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/jumps.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/jumps.s	2022-02-10 13:50:25.873367500 -0500
@@ -0,0 +1,8 @@
+
+	.text
+	.global jumps
+jumps:
+	jal jumps
+	jmp [r5]
+	jmp [lp]
+	jr jumps
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/logical.s binutils-2.27/gas/testsuite/gas/v810/logical.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/logical.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/logical.s	2022-02-10 13:50:25.880367900 -0500
@@ -0,0 +1,11 @@
+
+	.text
+	.global logicals
+logicals:
+	and r5,r6
+	andi 7,r5,r6
+	not r5,r6
+	or r5,r6
+	ori 7,r5,r6
+	xor r5,r6
+	xori 7,r5,r6
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/mem.s binutils-2.27/gas/testsuite/gas/v810/mem.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/mem.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/mem.s	2022-02-10 13:50:25.888368400 -0500
@@ -0,0 +1,14 @@
+
+	.text
+	.global memory
+memory:
+	ld.b 5[r5],r6
+	ld.h 4[r5],r6
+	ld.w 4[r5],r6
+	ld.w 4[gp],r6
+	ld.w 4[sp],lp
+	st.b r5,5[r6]
+	st.h r5,4[r6]
+	st.w r5,4[r6]
+	st.w r5,4[gp]
+	st.w lp,4[sp]
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/misc.s binutils-2.27/gas/testsuite/gas/v810/misc.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/misc.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/misc.s	2022-02-10 13:50:25.896368900 -0500
@@ -0,0 +1,11 @@
+
+	.text
+	.global misc
+misc:
+	halt
+	nop
+	reti
+	trap 0
+	trap 31
+	ldsr r7,psw
+	stsr psw,r7
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/move.s binutils-2.27/gas/testsuite/gas/v810/move.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/move.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/move.s	2022-02-10 13:50:25.903369300 -0500
@@ -0,0 +1,8 @@
+
+	.text
+	.global move
+move:
+	mov r5,r6
+	mov 5,r6
+	movea 7,r5,r6
+	movhi 7,r5,r6
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/range.s binutils-2.27/gas/testsuite/gas/v810/range.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/range.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/range.s	2022-02-10 13:50:25.911369700 -0500
@@ -0,0 +1,2 @@
+	.text
+	ld.b 0xff62[r0],r0
diff -Naur binutils-2.27-pure/gas/testsuite/gas/v810/reloc.s binutils-2.27/gas/testsuite/gas/v810/reloc.s
--- binutils-2.27-pure/gas/testsuite/gas/v810/reloc.s	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/gas/testsuite/gas/v810/reloc.s	2022-02-10 13:50:25.919370200 -0500
@@ -0,0 +1,6 @@
+	.text
+	movea lo(foo),r0,r1
+	movhi hi(foo),r1,r1
+	movhi hi0(foo),r1,r1
+	movea zdaoff(_foo),r0,r1
+	movhi sdaoff(_foo),gp,r1
diff -Naur binutils-2.27-pure/include/dis-asm.h binutils-2.27/include/dis-asm.h
--- binutils-2.27-pure/include/dis-asm.h	2016-08-03 03:36:53.000000000 -0400
+++ binutils-2.27/include/dis-asm.h	2022-02-10 13:50:25.930370800 -0500
@@ -302,6 +302,7 @@
 extern int print_insn_tic80		(bfd_vma, disassemble_info *);
 extern int print_insn_tilegx		(bfd_vma, disassemble_info *);
 extern int print_insn_tilepro		(bfd_vma, disassemble_info *);
+extern int print_insn_v810		(bfd_vma, disassemble_info *);
 extern int print_insn_v850		(bfd_vma, disassemble_info *);
 extern int print_insn_vax		(bfd_vma, disassemble_info *);
 extern int print_insn_visium		(bfd_vma, disassemble_info *);
diff -Naur binutils-2.27-pure/include/elf/common.h binutils-2.27/include/elf/common.h
--- binutils-2.27-pure/include/elf/common.h	2016-08-03 03:36:53.000000000 -0400
+++ binutils-2.27/include/elf/common.h	2022-02-10 13:50:25.943371500 -0500
@@ -374,6 +374,9 @@
 /* V850 backend magic number.  Written in the absense of an ABI.  */
 #define EM_CYGNUS_V850		0x9080
 
+/* V810 backend magic number.  Written in the absense of an ABI.  */
+#define EM_PCFX_V810		0x9081
+
 /* old S/390 backend magic number. Written in the absence of an ABI.  */
 #define EM_S390_OLD		0xa390
 
diff -Naur binutils-2.27-pure/include/elf/v810.h binutils-2.27/include/elf/v810.h
--- binutils-2.27-pure/include/elf/v810.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/include/elf/v810.h	2022-02-10 13:50:25.951372000 -0500
@@ -0,0 +1,102 @@
+/* V810 ELF support for BFD.
+   Copyright (C) 1997-2016 Free Software Foundation, Inc.
+   Created by Michael Meissner, Cygnus Support <meissner@cygnus.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* This file holds definitions specific to the MIPS ELF ABI.  Note
+   that most of this is not actually implemented by BFD.  */
+
+#ifndef _ELF_V810_H
+#define _ELF_V810_H
+
+/* Processor specific flags for the ELF header e_flags field.  */
+
+/* Four bit V810 architecture field.  */
+#define EF_V810_ARCH		0xf0000000
+
+/* v810 code.  */
+#define E_V810_ARCH		0x00000000
+
+/* Flags for the st_other field.  */
+#define V810_OTHER_SDA		0x10	/* Symbol had SDA relocations.  */
+#define V810_OTHER_ZDA		0x20	/* Symbol had ZDA relocations.  */
+#define V810_OTHER_TDA		0x40	/* Symbol had TDA relocations.  */
+#define V810_OTHER_ERROR	0x80	/* Symbol had an error reported.  */
+
+/* V810 relocations.  */
+#include "elf/reloc-macros.h"
+
+START_RELOC_NUMBERS (v810_reloc_type)
+     /* From binutils 2.10 */
+     RELOC_NUMBER (R_V810_NONE, 0)
+     RELOC_NUMBER (R_V810_9_PCREL, 1)
+     RELOC_NUMBER (R_V810_26_PCREL, 2)
+     RELOC_NUMBER (R_V810_HI16_S, 3)
+     RELOC_NUMBER (R_V810_HI16, 4)
+     RELOC_NUMBER (R_V810_LO16, 5)
+     RELOC_NUMBER (R_V810_ABS32, 6)
+     RELOC_NUMBER (R_V810_16, 7)
+     RELOC_NUMBER (R_V810_8, 8)
+     RELOC_NUMBER (R_V810_SDA_16_16_OFFSET, 9)		/* For ld.b, st.b, set1, clr1, not1, tst1, movea, movhi */
+     RELOC_NUMBER (R_V810_ZDA_16_16_OFFSET, 10)		/* For ld.b, st.b, set1, clr1, not1, tst1, movea, movhi */
+     RELOC_NUMBER (R_V810_TDA_16_16_OFFSET, 11)		/* For ld.b, st.b, set1, clr1, not1, tst1, movea, movhi */
+     RELOC_NUMBER (R_V810_GNU_VTINHERIT, 12)
+     RELOC_NUMBER (R_V810_GNU_VTENTRY, 13)
+     RELOC_NUMBER (R_V810_ALIGN, 14)
+
+END_RELOC_NUMBERS (R_V810_max)
+
+
+/* Processor specific section indices.  These sections do not actually
+   exist.  Symbols with a st_shndx field corresponding to one of these
+   values have a special meaning.  */
+
+/* Small data area common symbol.  */
+#define SHN_V810_SCOMMON	SHN_LORESERVE
+
+/* Thread data area common symbol.  */
+#define SHN_V810_TCOMMON	(SHN_LORESERVE + 1)
+
+/* Zero data area common symbol.  */
+#define SHN_V810_ZCOMMON	(SHN_LORESERVE + 2)
+
+
+/* Processor specific section types.  */
+
+/* Section contains the .scommon data.  */
+#define SHT_V810_SCOMMON	0x70000000
+
+/* Section contains the .scommon data.  */
+#define SHT_V810_TCOMMON	0x70000001
+
+/* Section contains the .scommon data.  */
+#define SHT_V810_ZCOMMON	0x70000002
+
+/* Processor specific section flags.  */
+
+/* This section must be in the small data area (pointed to by GP).  */
+#define SHF_V810_GPREL		0x10000000
+
+/* This section must be in the thread data area (pointed to by TP).  */
+#define SHF_V810_TPREL		0x20000000
+
+/* This section must be in the zero data area (pointed to by R0).  */
+#define SHF_V810_R0REL		0x40000000
+
+#endif /* _ELF_V810_H */
diff -Naur binutils-2.27-pure/include/opcode/v810.h binutils-2.27/include/opcode/v810.h
--- binutils-2.27-pure/include/opcode/v810.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/include/opcode/v810.h	2022-02-10 13:50:25.959372500 -0500
@@ -0,0 +1,168 @@
+/* v810.h -- Header file for NEC V810 opcode table
+   Copyright (C) 1996-2016 Free Software Foundation, Inc.
+   Written by J.T. Conklin, Cygnus Support
+
+   This file is part of GDB, GAS, and the GNU binutils.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version 3,
+   or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#ifndef V810_H
+#define V810_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The opcode table is an array of struct v810_opcode.  */
+
+struct v810_opcode
+{
+  /* The opcode name.  */
+  const char *name;
+
+  /* The opcode itself.  Those bits which will be filled in with
+     operands are zeroes.  */
+  unsigned long opcode;
+
+  /* The opcode mask.  This is used by the disassembler.  This is a
+     mask containing ones indicating those bits which must match the
+     opcode field, and zeroes indicating those bits which need not
+     match (and are presumably filled in by operands).  */
+  unsigned long mask;
+
+  /* An array of operand codes.  Each code is an index into the
+     operand table.  They appear in the order which the operands must
+     appear in assembly code, and are terminated by a zero.  */
+  unsigned char operands[8];
+
+  /* Which (if any) operand is a memory operand.  */
+  unsigned int memop;
+
+  /* Target processor(s).  A bit field of processors which support
+     this instruction.  Note a bit field is used as some instructions
+     are available on multiple, different processor types, whereas
+     other instructions are only available on one specific type.  */
+  unsigned int processors;
+};
+
+/* Values for the processors field in the v810_opcode structure.  */
+#define PROCESSOR_V810          (1 << 0)                /* Just the V810.  */
+#define PROCESSOR_VBOY          (1 << 0)                /* Just the VirtualBoy.  */
+
+#define PROCESSOR_ALL           (PROCESSOR_V810 | PROCESSOR_VBOY)
+#define PROCESSOR_MASK          (PROCESSOR_ALL)
+#define SET_PROCESSOR_MASK(mask,set)    ((mask) = ((mask) & ~PROCESSOR_MASK) | (set))
+
+/* The table itself is sorted by major opcode number, and is otherwise
+   in the order in which the disassembler should consider
+   instructions.  */
+extern const struct v810_opcode v810_opcodes[];
+extern const int v810_num_opcodes;
+
+
+/* The operands table is an array of struct v810_operand.  */
+
+struct v810_operand
+{
+  /* The number of bits in the operand.  */
+  /* If this value is -1 then the operand's bits are in a discontinous
+     distribution in the instruction. */
+  int bits;
+
+  /* (bits >= 0):  How far the operand is left shifted in the instruction.  */
+  /* (bits == -1): Bit mask of the bits in the operand.  */
+  int shift;
+
+  /* Insertion function.  This is used by the assembler.  To insert an
+     operand value into an instruction, check this field.
+
+     If it is NULL, execute
+         i |= (op & ((1 << o->bits) - 1)) << o->shift;
+     (i is the instruction which we are filling in, o is a pointer to
+     this structure, and op is the opcode value; this assumes twos
+     complement arithmetic).
+
+     If this field is not NULL, then simply call it with the
+     instruction and the operand value.  It will return the new value
+     of the instruction.  If the ERRMSG argument is not NULL, then if
+     the operand value is illegal, *ERRMSG will be set to a warning
+     string (the operand will be inserted in any case).  If the
+     operand value is legal, *ERRMSG will be unchanged (most operands
+     can accept any value).  */
+  unsigned long (* insert)
+    (unsigned long instruction, long op, const char ** errmsg);
+
+  /* Extraction function.  This is used by the disassembler.  To
+     extract this operand type from an instruction, check this field.
+
+     If it is NULL, compute
+         op = o->bits == -1 ? ((i) & o->shift) : ((i) >> o->shift) & ((1 << o->bits) - 1);
+         if (o->flags & V810_OPERAND_SIGNED)
+             op = (op << (32 - o->bits)) >> (32 - o->bits);
+     (i is the instruction, o is a pointer to this structure, and op
+     is the result; this assumes twos complement arithmetic).
+
+     If this field is not NULL, then simply call it with the
+     instruction value.  It will return the value of the operand.  If
+     the INVALID argument is not NULL, *INVALID will be set to
+     non-zero if this operand type can not actually be extracted from
+     this operand (i.e., the instruction does not match).  If the
+     operand is valid, *INVALID will not be changed.  */
+  unsigned long (* extract) (unsigned long instruction, int * invalid);
+
+  /* One bit syntax flags.  */
+  int flags;
+
+  int default_reloc;
+};
+
+/* Elements in the table are retrieved by indexing with values from
+   the operands field of the v810_opcodes table.  */
+
+extern const struct v810_operand v810_operands[];
+
+/* Values defined for the flags field of a struct v810_operand.  */
+
+/* This operand names a general purpose register.  */
+#define V810_OPERAND_REG        0x01
+
+/* This operand names a system register.  */
+#define V810_OPERAND_SRG        0x04
+
+/* This operand names a condition code used in the setf instruction.  */
+#define V810_OPERAND_CC         0x10
+
+/* This is a relaxable operand.   Only used for D9->D22 branch relaxing
+   right now.  We may need others in the future (or maybe handle them like
+   promoted operands on the mn10300?).  */
+#define V810_OPERAND_RELAX      0x800
+
+/* This operand takes signed values.  */
+#define V810_OPERAND_SIGNED     0x1000
+
+/* This operand is a displacement.  */
+#define V810_OPERAND_DISP       0x2000
+
+/* This operand is a PC displacement.  */
+#define V810_PCREL              0x4000
+
+extern int v810_msg_is_out_of_range (const char * msg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* V810_H */
diff -Naur binutils-2.27-pure/ld/Makefile.am binutils-2.27/ld/Makefile.am
--- binutils-2.27-pure/ld/Makefile.am	2016-08-03 03:36:54.000000000 -0400
+++ binutils-2.27/ld/Makefile.am	2022-02-10 13:50:25.973373300 -0500
@@ -423,6 +423,7 @@
 	etic4xcoff.c \
 	etic54xcoff.c \
 	etic80coff.c \
+	ev810.c \
 	ev850.c \
 	ev850_rh850.c \
 	evanilla.c \
@@ -1839,6 +1840,9 @@
 etic80coff.c: $(srcdir)/emulparams/tic80coff.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic80coff.sc ${GEN_DEPENDS}
 
+ev810.c: $(srcdir)/emulparams/v810.sh $(srcdir)/emultempl/v810elf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/v810.sc ${GEN_DEPENDS}
+
 ev850.c: $(srcdir)/emulparams/v850.sh $(srcdir)/emultempl/v850elf.em \
   $(ELF_DEPS) $(srcdir)/scripttempl/v850.sc ${GEN_DEPENDS}
 
diff -Naur binutils-2.27-pure/ld/Makefile.in binutils-2.27/ld/Makefile.in
--- binutils-2.27-pure/ld/Makefile.in	2016-08-03 03:36:54.000000000 -0400
+++ binutils-2.27/ld/Makefile.in	2022-02-10 13:50:25.989374200 -0500
@@ -791,6 +791,7 @@
 	etic4xcoff.c \
 	etic54xcoff.c \
 	etic80coff.c \
+	ev810.c \
 	ev850.c \
 	ev850_rh850.c \
 	evanilla.c \
@@ -1492,6 +1493,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic4xcoff.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic54xcoff.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic80coff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev810.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev850.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev850_rh850.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evanilla.Po@am__quote@
@@ -3427,6 +3429,9 @@
 etic80coff.c: $(srcdir)/emulparams/tic80coff.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic80coff.sc ${GEN_DEPENDS}
 
+ev810.c: $(srcdir)/emulparams/v810.sh $(srcdir)/emultempl/v810elf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/v810.sc ${GEN_DEPENDS}
+
 ev850.c: $(srcdir)/emulparams/v850.sh $(srcdir)/emultempl/v850elf.em \
   $(ELF_DEPS) $(srcdir)/scripttempl/v850.sc ${GEN_DEPENDS}
 
diff -Naur binutils-2.27-pure/ld/configure.tgt binutils-2.27/ld/configure.tgt
--- binutils-2.27-pure/ld/configure.tgt	2016-08-03 03:36:54.000000000 -0400
+++ binutils-2.27/ld/configure.tgt	2022-02-10 13:50:26.003375000 -0500
@@ -788,6 +788,8 @@
 tilepro-*-*)		targ_emul=elf32tilepro ;;
 ft32-*-*)		targ_emul=elf32ft32
 			;;
+v810*-*-*)		targ_emul=v810
+			;;
 v850*-*-*)		targ_emul=v850_rh850
 			targ_extra_emuls=v850
 			;;
diff -Naur binutils-2.27-pure/ld/emulparams/v810.sh binutils-2.27/ld/emulparams/v810.sh
--- binutils-2.27-pure/ld/emulparams/v810.sh	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/ld/emulparams/v810.sh	2022-02-10 13:50:26.010375400 -0500
@@ -0,0 +1,16 @@
+MACHINE=
+SCRIPT_NAME=v810
+EXTRA_EM_FILE=v810elf
+OUTPUT_FORMAT="elf32-v810"
+TEXT_START_ADDR=0x8000
+ZDATA_START_ADDR=0x0
+ROZDATA_START_ADDR="ALIGN (4)"
+SDATA_START_ADDR="ALIGN (8)"
+ROSDATA_START_ADDR="ALIGN (4)"
+TDATA_START_ADDR="ALIGN (8)"
+ARCH=v810
+MAXPAGESIZE=256
+ENTRY=_start
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+PCFX_FSYS_SDA_RESERVED=0x58
diff -Naur binutils-2.27-pure/ld/emultempl/v810elf.em binutils-2.27/ld/emultempl/v810elf.em
--- binutils-2.27-pure/ld/emultempl/v810elf.em	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/ld/emultempl/v810elf.em	2022-02-10 13:50:26.017375800 -0500
@@ -0,0 +1,30 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright (C) 2013-2016 Free Software Foundation, Inc.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+#
+
+# This file is sourced from elf32.em, and defines extra cpu specific
+# features.
+#
+fragment <<EOF
+/* #include "ldctor.h" */
+
+/* No cpu specific features on the V810!  */
+
+EOF
diff -Naur binutils-2.27-pure/ld/scripttempl/v810.sc binutils-2.27/ld/scripttempl/v810.sc
--- binutils-2.27-pure/ld/scripttempl/v810.sc	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/ld/scripttempl/v810.sc	2022-02-10 13:50:26.025376200 -0500
@@ -0,0 +1,228 @@
+# Copyright (C) 2014-2016 Free Software Foundation, Inc.
+# 
+# Copying and distribution of this file, with or without modification,
+# are permitted in any medium without royalty provided the copyright
+# notice and this notice are preserved.
+
+cat << EOF
+/* Copyright (C) 2014-2016 Free Software Foundation, Inc.
+
+   Copying and distribution of this script, with or without modification,
+   are permitted in any medium without royalty provided the copyright
+   notice and this notice are preserved.  */
+
+OUTPUT_FORMAT("elf32-v810", "elf32-v810", "elf32-v810")
+OUTPUT_ARCH(v810)
+${RELOCATING+ENTRY(_start)}
+SEARCH_DIR(.);
+EXTERN(__gp __tp __tpend __zpdat __zpbss __zpend);
+SECTIONS
+{
+  /* Read-only sections, merged into text segment.  */
+  . = 0x8000;
+
+  .text		ALIGN (4) :
+  {
+    *(.text)
+    ${RELOCATING+*(.text.*)}
+    
+    /* .gnu.warning sections are handled specially by elf32.em.  */
+    *(.gnu.warning)
+    *(.gnu.linkonce.t*)
+  } =0
+
+  ${RELOCATING+_etext = .;}
+  ${RELOCATING+PROVIDE (etext = .);}
+
+  .init		: { KEEP (*(.init)) } =0
+  .fini		: { KEEP (*(.fini)) } =0
+
+  .rodata	ALIGN (4) :
+  {
+    *(.rodata)
+    ${RELOCATING+*(.rodata.*)}
+    *(.gnu.linkonce.r*)
+  }
+  .rodata1	: { *(.rodata1) }
+
+  .data         ALIGN (4) :
+  {
+    *(.data)
+    ${RELOCATING+*(.data.*)}
+    *(.gnu.linkonce.d*)
+    CONSTRUCTORS
+  }
+  .data1	: { *(.data1) }
+
+  .ctors	ALIGN (4) :
+  {
+    ${CONSTRUCTING+___ctors = .;}
+    KEEP (*(EXCLUDE_FILE (*crtend.o) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*crtend(.ctors))
+    ${CONSTRUCTING+___ctors_end = .;}
+  }
+
+  /* Discard these sections on PC-FX & VirtualBoy.  */
+
+  /DISCARD/     :
+  {
+    *(.dtors)
+    *(.dtors.*)
+    *(.gcc_except_table)
+  }
+
+  /* Extra section for 32KB/64KB of tp (aka R5) relative addressing.
+     This could for thread-local variables instead if we get fancy.  */
+
+  .tdata        ALIGN (8) :
+  {
+	${RELOCATING+PROVIDE (__tp = .);}
+	*(.tbyte)
+	*(.tcommon_byte)
+	*(.tdata)
+	*(.tbss)
+	*(.tcommon)
+	${RELOCATING+. = ALIGN (8);}
+	${RELOCATING+PROVIDE (__tpend = .);}
+  }
+
+  /* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+     
+  .sdata        ALIGN (8) :
+  {
+	${RELOCATING+PROVIDE (__gp = . + 0x8000);}
+	${RELOCATING+. = ${PCFX_FSYS_SDA_RESERVED};}
+	*(.sdata)
+  }
+
+  /* This is the read only part of the small data area.
+     Having it as a seperate section prevents its
+     attributes from being inherited by the sdata
+     section.  Specifically it prevents the sdata
+     section from being marked READONLY.  */
+
+  .rosdata      ALIGN (4) :
+  {
+	*(.rosdata)
+  }
+
+  /* We place the .sbss data section AFTER the .rosdata section, so that
+     it can directly preceed the .bss section.  This allows runtime startup
+     code to initialise all the zero-data sections by simply taking the
+     value of '_edata' and zeroing until it reaches '_end'.  */
+
+  /* 8-byte align these sections to speed up clearing them in crt0.S  */
+
+  ${RELOCATING+. = ALIGN (8);}
+
+  .sbss         ALIGN (4) :
+  {
+	${RELOCATING+__sbss_start = .;}
+	*(.sbss)
+	*(.scommon)
+  }
+
+  ${RELOCATING+_edata  = DEFINED (__sbss_start) ? __sbss_start : . ;}
+  ${RELOCATING+PROVIDE (edata = _edata);}
+
+  .bss          ALIGN (4) :
+  {
+	${RELOCATING+__bss_start = DEFINED (__sbss_start) ? __sbss_start : . ;}
+	${RELOCATING+__real_bss_start = . ;}
+	*(.dynbss)
+	*(.bss)
+	*(COMMON)
+  }
+
+  ${RELOCATING+. = ALIGN (8);}
+  ${RELOCATING+_end = . ;}
+  ${RELOCATING+PROVIDE (end = .);}
+  ${RELOCATING+PROVIDE (_heap_start = .);}
+
+  /* Put all initialized R0-relative data at the end of the output file on
+     top of the .sbss/.bss sections so that it can be copied into place at
+     startup and then wiped to zero for use as the .sbss/.bss  */
+
+  . = 0x0000;
+
+  /* 8-byte align these sections to speed up relocating them in crt0.S  */
+
+  ${RELOCATING+. = ALIGN (8)};
+  ${RELOCATING+PROVIDE (__zpdat = .);}
+
+  .zdata : AT ( _edata )
+  {
+	*(.rozdata)
+	*(.zdata)
+        ${RELOCATING+. = ALIGN (8)};
+  }
+
+  ${RELOCATING+PROVIDE (__zpbss = .);}
+
+  .zbss : AT ( ADDR (.zdata) + SIZEOF (.zdata) )
+  {
+	*(.zbss)
+	*(.zcommon)
+        ${RELOCATING+. = ALIGN (8)};
+  }
+
+  ${RELOCATING+PROVIDE (__zpend = .);}
+
+  /* Stabs debugging sections.  */
+  .stab 0		: { *(.stab) }
+  .stabstr 0		: { *(.stabstr) }
+  .stab.excl 0		: { *(.stab.excl) }
+  .stab.exclstr 0	: { *(.stab.exclstr) }
+  .stab.index 0		: { *(.stab.index) }
+  .stab.indexstr 0	: { *(.stab.indexstr) }
+  .comment 0		: { *(.comment) }
+
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0	: { *(.debug) }
+  .line           0	: { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0	: { *(.debug_srcinfo) }
+  .debug_sfnames  0	: { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0	: { *(.debug_aranges) }
+  .debug_pubnames 0	: { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0	: { *(.debug_info) *(.gnu.linkonce.wi.*) }
+  .debug_abbrev   0	: { *(.debug_abbrev) }
+  .debug_line     0	: { *(.debug_line) }
+  .debug_frame    0	: { *(.debug_frame) }
+  .debug_str      0	: { *(.debug_str) }
+  .debug_loc      0	: { *(.debug_loc) }
+  .debug_macinfo  0	: { *(.debug_macinfo) }
+
+  /* SGI/MIPS DWARF 2 extensions.  */
+  .debug_weaknames 0	: { *(.debug_weaknames) }
+  .debug_funcnames 0	: { *(.debug_funcnames) }
+  .debug_typenames 0	: { *(.debug_typenames) }
+  .debug_varnames  0	: { *(.debug_varnames) }
+
+  /* DWARF 3 */
+  .debug_pubtypes 0 : { *(.debug_pubtypes) }
+  .debug_ranges   0 : { *(.debug_ranges) }
+
+  /* DWARF Extension.  */
+  .debug_macro    0 : { *(.debug_macro) } 
+
+  /* User stack.  */
+  .stack 0x200000	:
+  {
+	${RELOCATING+__stack = .;}
+	*(.stack)
+  }
+}
+EOF
diff -Naur binutils-2.27-pure/opcodes/Makefile.am binutils-2.27/opcodes/Makefile.am
--- binutils-2.27-pure/opcodes/Makefile.am	2016-08-03 03:36:54.000000000 -0400
+++ binutils-2.27/opcodes/Makefile.am	2022-02-10 13:50:26.039377000 -0500
@@ -249,6 +249,8 @@
 	tilegx-opc.c \
 	tilepro-dis.c \
 	tilepro-opc.c \
+	v810-dis.c \
+	v810-opc.c \
 	v850-dis.c \
 	v850-opc.c \
 	vax-dis.c \
diff -Naur binutils-2.27-pure/opcodes/Makefile.in binutils-2.27/opcodes/Makefile.in
--- binutils-2.27-pure/opcodes/Makefile.in	2016-08-03 03:36:54.000000000 -0400
+++ binutils-2.27/opcodes/Makefile.in	2022-02-10 13:50:26.057378100 -0500
@@ -550,6 +550,8 @@
 	tilegx-opc.c \
 	tilepro-dis.c \
 	tilepro-opc.c \
+	v810-dis.c \
+	v810-opc.c \
 	v850-dis.c \
 	v850-opc.c \
 	vax-dis.c \
@@ -953,6 +955,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilegx-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilepro-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilepro-opc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v810-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v810-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v850-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v850-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vax-dis.Plo@am__quote@
diff -Naur binutils-2.27-pure/opcodes/configure binutils-2.27/opcodes/configure
--- binutils-2.27-pure/opcodes/configure	2022-02-10 13:45:25.203716800 -0500
+++ binutils-2.27/opcodes/configure	2022-02-10 13:50:26.099380500 -0500
@@ -12671,6 +12671,7 @@
 	bfd_tic80_arch)		ta="$ta tic80-dis.lo tic80-opc.lo" ;;
 	bfd_tilegx_arch)	ta="$ta tilegx-dis.lo tilegx-opc.lo" ;;
 	bfd_tilepro_arch)	ta="$ta tilepro-dis.lo tilepro-opc.lo" ;;
+	bfd_v810_arch)		ta="$ta v810-opc.lo v810-dis.lo" ;;
 	bfd_v850_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850e_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850ea_arch)	ta="$ta v850-opc.lo v850-dis.lo" ;;
diff -Naur binutils-2.27-pure/opcodes/configure.ac binutils-2.27/opcodes/configure.ac
--- binutils-2.27-pure/opcodes/configure.ac	2016-08-03 03:36:54.000000000 -0400
+++ binutils-2.27/opcodes/configure.ac	2022-02-10 13:50:26.114381300 -0500
@@ -339,6 +339,7 @@
 	bfd_tic80_arch)		ta="$ta tic80-dis.lo tic80-opc.lo" ;;
 	bfd_tilegx_arch)	ta="$ta tilegx-dis.lo tilegx-opc.lo" ;;
 	bfd_tilepro_arch)	ta="$ta tilepro-dis.lo tilepro-opc.lo" ;;
+	bfd_v810_arch)		ta="$ta v810-opc.lo v810-dis.lo" ;;
 	bfd_v850_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850e_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850ea_arch)	ta="$ta v850-opc.lo v850-dis.lo" ;;
diff -Naur binutils-2.27-pure/opcodes/disassemble.c binutils-2.27/opcodes/disassemble.c
--- binutils-2.27-pure/opcodes/disassemble.c	2016-08-03 03:36:54.000000000 -0400
+++ binutils-2.27/opcodes/disassemble.c	2022-02-10 13:50:26.125382000 -0500
@@ -88,6 +88,7 @@
 #define ARCH_tic80
 #define ARCH_tilegx
 #define ARCH_tilepro
+#define ARCH_v810
 #define ARCH_v850
 #define ARCH_vax
 #define ARCH_visium
@@ -451,6 +452,11 @@
       disassemble = print_insn_ft32;
       break;
 #endif
+#ifdef ARCH_v810
+    case bfd_arch_v810:
+      disassemble = print_insn_v810;
+      break;
+#endif
 #ifdef ARCH_v850
     case bfd_arch_v850:
     case bfd_arch_v850_rh850:
diff -Naur binutils-2.27-pure/opcodes/v810-dis.c binutils-2.27/opcodes/v810-dis.c
--- binutils-2.27-pure/opcodes/v810-dis.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/opcodes/v810-dis.c	2022-02-10 13:50:26.133382400 -0500
@@ -0,0 +1,344 @@
+/* Disassemble V810 instructions.
+   Copyright (C) 1996-2016 Free Software Foundation, Inc.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "opcode/v810.h"
+#include "dis-asm.h"
+#include "opintl.h"
+
+static const char *const v810_reg_names[] =
+{
+  "r0", "r1", "fp", "sp", "gp", "tp", "r6", "r7",
+  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
+  "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
+  "r24", "r25", "r26", "r27", "r28", "r29", "r30", "lp"
+};
+
+static const char *const v810_sreg_names[] =
+{
+  "eipc", "eipsw", "fepc", "fepsw", "ecr", "psw", "pir", "tkcw",
+  "sr8", "sr9", "sr10", "sr11", "sr12", "sr13", "sr14", "sr15",
+  "sr16", "sr17", "sr18", "sr19", "sr20", "sr21", "sr22", "sr23",
+  "chcw", "adtre", "sr26", "sr27", "sr28", "sr29", "sr30", "sr31"
+};
+
+static const char *const v810_cc_names[] =
+{
+  "v", "c/l", "z", "nh", "s/n", "t", "lt", "le",
+  "nv", "nc/nl", "nz", "h", "ns/p", "sa", "ge", "gt"
+};
+
+static void
+print_value (int flags,
+	     bfd_vma memaddr,
+	     struct disassemble_info *info,
+	     long value)
+{
+  if (flags & V810_PCREL)
+    {
+      bfd_vma addr = value + memaddr;
+      info->print_address_func (addr, info);
+    }
+  else if (flags & V810_OPERAND_DISP)
+    {
+      if (flags & V810_OPERAND_SIGNED)
+        {
+          info->fprintf_func (info->stream, "%ld", value);
+        }
+      else
+        {
+          info->fprintf_func (info->stream, "%lu", value);
+        }
+    }
+  else
+    {
+      if (flags & V810_OPERAND_SIGNED)
+        {
+          info->fprintf_func (info->stream, "%ld", value);
+        }
+      else
+        {
+          info->fprintf_func (info->stream, "%lu", value);
+        }
+    }
+}
+
+static long
+get_operand_value (const struct v810_operand *operand,
+                   unsigned long insn,
+                   int *invalid)
+{
+  long value;
+
+  if (operand->extract)
+    value = (operand->extract) (insn, invalid);
+  else
+    {
+      if (operand->bits == -1)
+        value = (insn & operand->shift);
+      else
+        value = (insn >> operand->shift) & ((1 << operand->bits) - 1);
+
+      if (operand->flags & V810_OPERAND_SIGNED)
+        value = ((long)(value << (sizeof (long)*8 - operand->bits))
+                 >> (sizeof (long)*8 - operand->bits));
+    }
+
+  return value;
+}
+
+
+static int
+disassemble (bfd_vma memaddr,
+	     struct disassemble_info *info,
+	     int bytes_read,
+	     unsigned long insn)
+{
+  struct v810_opcode *op = (struct v810_opcode *)v810_opcodes;
+  const struct v810_operand *operand;
+  int match = 0;
+  int target_processor;
+
+  switch (info->mach)
+    {
+    case 0:
+    default:
+      target_processor = PROCESSOR_V810;
+      break;
+    }
+
+  /* If this is a two byte insn, then mask off the high bits.  */
+  if (bytes_read == 2)
+    insn &= 0xffff;
+
+  /* Find the opcode.  */
+  while (op->name)
+    {
+      if ((op->mask & insn) == op->opcode
+          && (op->processors & target_processor))
+        {
+          /* Code check start.  */
+          const unsigned char *opindex_ptr;
+          unsigned int opnum;
+          unsigned int memop;
+
+          for (opindex_ptr = op->operands, opnum = 1;
+               *opindex_ptr != 0;
+               opindex_ptr++, opnum++)
+            {
+              int invalid = 0;
+
+              operand = &v810_operands[*opindex_ptr];
+
+              get_operand_value (operand, insn, &invalid);
+
+              if (invalid)
+                goto next_opcode;
+            }
+
+          /* Code check end.  */
+
+          match = 1;
+          (*info->fprintf_func) (info->stream, "%s\t", op->name);
+#if 0
+          fprintf (stderr, "match: insn: %lx, mask: %lx, opcode: %lx, name: %s\n",
+                   insn, op->mask, op->opcode, op->name );
+#endif
+
+          memop = op->memop;
+          /* Now print the operands.
+
+             MEMOP is the operand number at which a memory
+             address specification starts, or zero if this
+             instruction has no memory addresses.
+
+             A memory address is always two arguments.
+
+             This information allows us to determine when to
+             insert commas into the output stream as well as
+             when to insert disp[reg] expressions onto the
+             output stream.  */
+
+          for (opindex_ptr = op->operands, opnum = 1;
+               *opindex_ptr != 0;
+               opindex_ptr++, opnum++)
+            {
+              bfd_boolean square = FALSE;
+              long value;
+              int flag;
+              char *prefix;
+
+              operand = &v810_operands[*opindex_ptr];
+
+              value = get_operand_value (operand, insn, 0);
+
+              /* The first operand is always output without any
+                 special handling.
+
+                 For the following arguments:
+
+                   If memop && opnum == memop + 1, then we need '[' since
+                   we're about to output the register used in a memory
+                   reference.
+
+                   If memop && opnum == memop + 2, then we need ']' since
+                   we just finished the register in a memory reference.  We
+                   also need a ',' before this operand.
+
+                   Else we just need a comma.
+
+                   We may need to output a trailing ']' if the last operand
+                   in an instruction is the register for a memory address.
+
+                   The exception (and there's always an exception) is the
+                   "jmp" insn which needs square brackets around it's only
+                   register argument.  */
+              prefix = "";
+
+              if (opnum == 1 && opnum == memop)
+                {
+                  info->fprintf_func (info->stream, "%s[", prefix);
+                  square = TRUE;
+                }
+              else if (opnum > 1
+                       && (v810_operands[*(opindex_ptr - 1)].flags & V810_OPERAND_DISP) != 0
+                       && opnum == memop)
+                {
+                  info->fprintf_func (info->stream, "%s[", prefix);
+                  square = TRUE;
+                }
+              else if (opnum > 1)
+                info->fprintf_func (info->stream, ", %s", prefix);
+
+              /* Extract the flags, ignoring ones which do not effect disassembly output.  */
+              flag = operand->flags & (V810_OPERAND_REG
+                                       | V810_OPERAND_SRG
+                                       | V810_OPERAND_CC);
+
+              switch (flag)
+                {
+                case V810_OPERAND_REG:  info->fprintf_func (info->stream, "%s", v810_reg_names[value]); break;
+                case V810_OPERAND_SRG:  info->fprintf_func (info->stream, "%s", v810_sreg_names[value]); break;
+
+                case V810_OPERAND_CC:   info->fprintf_func (info->stream, "%s", v810_cc_names[value]); break;
+
+                default:
+                  print_value (operand->flags, memaddr, info, value);
+                  break;
+                }
+
+              if (square)
+                (*info->fprintf_func) (info->stream, "]");
+            }
+
+          /* All done. */
+          break;
+        }
+    next_opcode:
+      op++;
+    }
+
+  return match;
+}
+
+int
+print_insn_v810 (bfd_vma memaddr, struct disassemble_info * info)
+{
+  int status, status2, match;
+  bfd_byte buffer[8];
+  int length = 0, code_length = 0;
+  unsigned long insn = 0;
+
+  status = info->read_memory_func (memaddr, buffer, 2, info);
+
+  if (status)
+    {
+      info->memory_error_func (status, memaddr, info);
+      return -1;
+    }
+
+  insn = bfd_getl16 (buffer);
+
+  status2 = info->read_memory_func (memaddr+2, buffer, 2 , info);
+
+  if (!status2)
+    {
+      bfd_getl16 (buffer);
+      /* fprintf (stderr, "insn2 0x%08lx\n", insn2); */
+    }
+
+  /* Special case.  */
+  if (length == 4
+      || (length == 0
+          && (insn & 0xfc00) >= 0xa000))
+    {
+      /* This is a 4 byte insn.  */
+      status = info->read_memory_func (memaddr, buffer, 4, info);
+      if (!status)
+        {
+          insn = bfd_getl32 (buffer);
+
+          if (!length)
+            length = code_length = 4;
+        }
+    }
+
+  if (code_length > length)
+    {
+      status = info->read_memory_func (memaddr + length, buffer, code_length - length, info);
+      if (status)
+        length = 0;
+    }
+
+  if (length == 0 && !status)
+    length = code_length = 2;
+
+  if (length == 2)
+    insn &= 0xffff;
+
+  match = disassemble (memaddr, info, length, insn);
+
+  if (!match)
+    {
+      int l = 0;
+
+      status = info->read_memory_func (memaddr, buffer, code_length, info);
+
+      while (l < code_length)
+        {
+          if (code_length - l == 2)
+            {
+              insn = bfd_getl16 (buffer + l) & 0xffff;
+              info->fprintf_func (info->stream, ".short\t0x%04lx", insn);
+              l += 2;
+            }
+          else
+            {
+              insn = bfd_getl32 (buffer + l);
+              info->fprintf_func (info->stream, ".long\t0x%08lx", insn);
+              l += 4;
+            }
+        }
+    }
+
+  return code_length;
+}
diff -Naur binutils-2.27-pure/opcodes/v810-opc.c binutils-2.27/opcodes/v810-opc.c
--- binutils-2.27-pure/opcodes/v810-opc.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.27/opcodes/v810-opc.c	2022-02-10 13:50:26.141382900 -0500
@@ -0,0 +1,319 @@
+/* Assemble V810 instructions.
+   Copyright (C) 1996-2016 Free Software Foundation, Inc.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "opcode/v810.h"
+#include "bfd.h"
+#include "opintl.h"
+
+/* One-word opcodes.  */
+#define one(x)          ((unsigned int) (x))
+
+/* Two-word opcodes.  */
+#define two(x,y)        ((unsigned int) (x) | ((unsigned int) (y) << 16))
+
+
+/* The functions used to insert and extract complicated operands.  */
+
+/* Note: There is a conspiracy between these functions and
+   v810_insert_operand() in gas/config/tc-v810.c.  Error messages
+   containing the string 'out of range' will be ignored unless a
+   specific command line option is given to GAS.  */
+
+static const char * out_of_range = N_ ("displacement value is out of range");
+
+static const char * immediate_out_of_range = N_ ("immediate value is out of range");
+static const char * branch_out_of_range = N_ ("branch value out of range");
+static const char * branch_out_of_range_and_odd_offset = N_ ("branch value not in range and to odd offset");
+static const char * branch_to_odd_offset = N_ ("branch to odd offset");
+
+
+int
+v810_msg_is_out_of_range (const char* msg)
+{
+  return msg == out_of_range
+    || msg == immediate_out_of_range
+    || msg == branch_out_of_range;
+}
+
+static unsigned long
+insert_d9 (unsigned long insn, long value, const char ** errmsg)
+{
+  if (value > 0xff || value < -0x100)
+    {
+      if ((value % 2) != 0)
+        * errmsg = branch_out_of_range_and_odd_offset;
+      else
+        * errmsg = branch_out_of_range;
+    }
+  else if ((value % 2) != 0)
+    * errmsg = branch_to_odd_offset;
+
+  return insn | (value & 0x1fe);
+}
+
+static unsigned long
+extract_d9 (unsigned long insn, int * invalid)
+{
+  unsigned long ret = (insn & 0x1fe);
+
+  ret = (ret ^ 0x100) - 0x100;
+
+  if (invalid != 0)
+    *invalid = 0;
+  return ret;
+}
+
+static unsigned long
+insert_d26 (unsigned long insn, long value, const char ** errmsg)
+{
+  if (value > 0x1ffffff || value < -0x2000000)
+    {
+      if ((value % 2) != 0)
+        * errmsg = branch_out_of_range_and_odd_offset;
+      else
+        * errmsg = branch_out_of_range;
+    }
+  else if ((value % 2) != 0)
+    * errmsg = branch_to_odd_offset;
+
+  return insn | ((value & 0xfffe) << 16) | ((value & 0x3ff0000) >> 16);
+}
+
+static unsigned long
+extract_d26 (unsigned long insn, int * invalid)
+{
+  signed long ret = ((insn >> 16) & 0xfffe) | ((insn << 16) & 0x3ff0000);
+
+  ret = (ret ^ 0x2000000) - 0x2000000;
+
+  if (invalid != 0)
+    *invalid = 0;
+  return (unsigned long) ret;
+}
+
+
+/* Warning: code in gas/config/tc-v810.c examines the contents of this array.
+   If you change any of the values here, be sure to look for side effects in
+   that code.  */
+const struct v810_operand v810_operands[] =
+{
+#define UNUSED    (0)
+  { 0, 0, NULL, NULL, 0, BFD_RELOC_NONE },
+
+#define R1        (1)
+  /* The R1 (src) field in a format 1, 5, 6, or 7 insn. */
+  { 5, 0, NULL, NULL, V810_OPERAND_REG, BFD_RELOC_NONE },
+
+#define R2        (2)
+  /* The R2 (dst) field in a format 1, 2, 5, 6, or 7 insn. */
+  { 5, 5, NULL, NULL, V810_OPERAND_REG, BFD_RELOC_NONE },
+
+#define I5        (3)
+  /* The imm5 (signed) field in a format 2 (imm-reg) insn. */
+  { 5, 0, NULL, NULL, V810_OPERAND_SIGNED, BFD_RELOC_NONE },
+
+#define I5U       (4)
+  /* The imm5 (unsigned) field in a format 2 (imm-reg) insn. */
+  { 5, 0, NULL, NULL, 0, BFD_RELOC_NONE },
+
+#define D9_RELAX  (5)
+  /* The DISP9 field in a format 3 (conditional branch) insn. RELAXABLE! */
+  { 9, 0, insert_d9, extract_d9, V810_OPERAND_RELAX | V810_OPERAND_SIGNED | V810_OPERAND_DISP | V810_PCREL, BFD_RELOC_V810_9_PCREL },
+
+#define D26       (6)
+  /* The DISP26 field in a format 4 (jr/jal) insn. MUST follow D9_RELAX!!! */
+  { 26, 0, insert_d26, extract_d26, V810_OPERAND_SIGNED | V810_OPERAND_DISP | V810_PCREL, BFD_RELOC_V810_26_PCREL },
+
+#define I16       (7)
+  /* The imm16 (signed) field in a format 5 (3-operand) insn. */
+  { 16, 16, NULL, NULL, V810_OPERAND_SIGNED, BFD_RELOC_16 },
+
+#define I16U      (8)
+  /* The imm16 (unsigned) field in a format 5 (3-operand) insn. */
+  { 16, 16, NULL, NULL, 0, BFD_RELOC_16 },
+
+#define D16       (9)
+  /* The disp16 field in a format 6 (load/store) insn. */
+  { 16, 16, NULL, NULL, V810_OPERAND_SIGNED | V810_OPERAND_DISP, BFD_RELOC_16 },
+
+#define SR        (10)
+  /* System register operands. */
+  { 5, 0, NULL, NULL, V810_OPERAND_SRG, BFD_RELOC_NONE },
+
+#define CCCC      (11)
+  /* The 4 bit condition code in a setf instruction. */
+  { 4, 0, NULL, NULL, V810_OPERAND_CC, BFD_RELOC_NONE },
+};
+
+
+/* The opcode table.
+
+   The format of the opcode table is:
+
+   NAME         OPCODE                  MASK                   { OPERANDS }        MEMOP    PROCESSOR
+
+   NAME is the name of the instruction.
+   OPCODE is the instruction opcode.
+   MASK is the opcode mask; this is used to tell the disassembler
+     which bits in the actual opcode must match OPCODE.
+   OPERANDS is the list of operands.
+   MEMOP specifies which operand (if any) is a memory operand.
+   PROCESSORS specifies which CPU(s) support the opcode.
+
+   The disassembler reads the table in order and prints the first
+   instruction which matches, so this table is sorted to put more
+   specific instructions before more general instructions.  It is also
+   sorted by major opcode.
+
+   The table is also sorted by name.  This is used by the assembler.
+   When parsing an instruction the assembler finds the first occurance
+   of the name of the instruciton in this table and then attempts to
+   match the instruction's arguments with description of the operands
+   associated with the entry it has just found in this table.  If the
+   match fails the assembler looks at the next entry in this table.
+   If that entry has the same name as the previous entry, then it
+   tries to match the instruction against that entry and so on.  This
+   is how the assembler copes with multiple, different formats of the
+   same instruction.  */
+
+const struct v810_opcode v810_opcodes[] =
+{
+{ "add",         one (0x0400),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "add",         one (0x4400),          one (0xfc00),          {I5, R2},       0, PROCESSOR_ALL  },
+{ "addf.s",      two (0xf800, 0x1000),  two (0xfc00, 0xfc00),  {R1, R2},       0, PROCESSOR_ALL  },
+{ "addi",        two (0xa400, 0x0000),  two (0xfc00, 0x0000),  {I16, R1, R2},  0, PROCESSOR_ALL  },
+{ "and",         one (0x3400),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "andi",        two (0xb400, 0x0000),  two (0xfc00, 0x0000),  {I16U, R1, R2}, 0, PROCESSOR_ALL  },
+
+{ "bc",          one (0x8200),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "be",          one (0x8400),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bge",         one (0x9c00),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bgt",         one (0x9e00),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bh",          one (0x9600),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bl",          one (0x8200),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "ble",         one (0x8e00),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "blt",         one (0x8c00),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bn",          one (0x8800),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bnc",         one (0x9200),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bne",         one (0x9400),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bnh",         one (0x8600),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bnl",         one (0x9200),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bnv",         one (0x9000),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bnz",         one (0x9400),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bp",          one (0x9800),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "br",          one (0x8a00),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "breakpoint",  one (0x601F),          one (0xffff),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "brkret",      one (0x6401),          one (0xfc01),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "bv",          one (0x8000),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+{ "bz",          one (0x8400),          one (0xfe01),          {D9_RELAX},     0, PROCESSOR_ALL  },
+
+{ "caxi",        two (0xe800, 0x0000),  two (0xfc00, 0x0000),  {D16, R1, R2},  2, PROCESSOR_ALL  },
+{ "cli",         one (0x5800),          one (0xfc00),          {UNUSED},       0, PROCESSOR_VBOY },
+{ "cmp",         one (0x0c00),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "cmp",         one (0x4c00),          one (0xfc00),          {I5, R2},       0, PROCESSOR_ALL  },
+{ "cmpf.s",      two (0xf800, 0x0000),  two (0xfc00, 0xfc00),  {R1, R2},       0, PROCESSOR_ALL  },
+{ "cvt.ws",      two (0xf800, 0x0800),  two (0xfc00, 0xfc00),  {R1, R2},       0, PROCESSOR_ALL  },
+{ "cvt.sw",      two (0xf800, 0x0c00),  two (0xfc00, 0xfc00),  {R1, R2},       0, PROCESSOR_ALL  },
+
+{ "div",         one (0x2400),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "divf.s",      two (0xf800, 0x1c00),  two (0xfc00, 0xfc00),  {R1, R2},       0, PROCESSOR_ALL  },
+{ "divu",        one (0x2c00),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+
+{ "halt",        one (0x6800),          one (0xfc01),          {UNUSED},       0, PROCESSOR_ALL  },
+
+{ "in.b",        two (0xe000, 0x0000),  two (0xfc00, 0x0000),  {D16, R1, R2},  2, PROCESSOR_ALL  },
+{ "in.h",        two (0xe400, 0x0000),  two (0xfc00, 0x0000),  {D16, R1, R2},  2, PROCESSOR_ALL  },
+{ "in.w",        two (0xec00, 0x0000),  two (0xfc00, 0x0000),  {D16, R1, R2},  2, PROCESSOR_ALL  },
+
+{ "jal",         two (0xac00, 0x0000),  two (0xfc00, 0x0000),  {D26},          0, PROCESSOR_ALL  },
+{ "jmp",         one (0x1800),          one (0xfc00),          {R1},           2, PROCESSOR_ALL  },
+{ "jr",          two (0xa800, 0x0000),  two (0xfc00, 0x0000),  {D26},          0, PROCESSOR_ALL  },
+ 
+{ "ld.b",        two (0xc000, 0x0000),  two (0xfc00, 0x0000),  {D16, R1, R2},  2, PROCESSOR_ALL  },
+{ "ld.h",        two (0xc400, 0x0000),  two (0xfc00, 0x0000),  {D16, R1, R2},  2, PROCESSOR_ALL  },
+{ "ld.w",        two (0xcc00, 0x0000),  two (0xfc00, 0x0000),  {D16, R1, R2},  2, PROCESSOR_ALL  },
+{ "ldsr",        one (0x7000),          one (0xfc00),          {R2, SR},       0, PROCESSOR_ALL  },
+
+{ "mov",         one (0x0000),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "mov",         one (0x4000),          one (0xfc00),          {I5, R2},       0, PROCESSOR_ALL  },
+{ "movea",       two (0xa000, 0x0000),  two (0xfc00, 0x0000),  {I16, R1, R2},  0, PROCESSOR_ALL  },
+{ "movhi",       two (0xbc00, 0x0000),  two (0xfc00, 0x0000),  {I16, R1, R2},  0, PROCESSOR_ALL  },
+{ "mpyhw",       two (0xf800, 0x3000),  two (0xfc00, 0xfc00),  {R1, R2},       0, PROCESSOR_VBOY },
+{ "mul",         one (0x2000),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "mulf.s",      two (0xf800, 0x1800),  two (0xfc00, 0xfc00),  {R1, R2},       0, PROCESSOR_ALL  },
+{ "mulu",        one (0x2800),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+
+{ "nop",         one (0x9a00),          one (0xfe01),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "not",         one (0x3c00),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+
+{ "or",          one (0x3000),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "ori",         two (0xb000, 0x0000),  two (0xfc00, 0x0000),  {I16U, R1, R2}, 0, PROCESSOR_ALL  },
+{ "out.b",       two (0xf000, 0x0000),  two (0xfc00, 0x0000),  {R2, D16, R1},  3, PROCESSOR_ALL  },
+{ "out.h",       two (0xf400, 0x0000),  two (0xfc00, 0x0000),  {R2, D16, R1},  3, PROCESSOR_ALL  },
+{ "out.w",       two (0xfc00, 0x0000),  two (0xfc00, 0x0000),  {R2, D16, R1},  3, PROCESSOR_ALL  },
+
+{ "reti",        one (0x6400),          one (0xfc01),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "rev",         two (0xf800, 0x2800),  two (0xfc00, 0xfc00),  {R1, R2},       0, PROCESSOR_VBOY },
+
+{ "sar",         one (0x1c00),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "sar",         one (0x5c00),          one (0xfc00),          {I5U, R2},      0, PROCESSOR_ALL  },
+{ "sei",         one (0x7800),          one (0xfc00),          {UNUSED},       0, PROCESSOR_VBOY },
+{ "setf",        one (0x4800),          one (0xfc00),          {CCCC, R2},     0, PROCESSOR_ALL  },
+{ "shl",         one (0x1000),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "shl",         one (0x5000),          one (0xfc00),          {I5U, R2},      0, PROCESSOR_ALL  },
+{ "shr",         one (0x1400),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "shr",         one (0x5400),          one (0xfc00),          {I5U, R2},      0, PROCESSOR_ALL  },
+{ "st.b",        two (0xd000, 0x0000),  two (0xfc00, 0x0000),  {R2, D16, R1},  3, PROCESSOR_ALL  },
+{ "st.h",        two (0xd400, 0x0000),  two (0xfc00, 0x0000),  {R2, D16, R1},  3, PROCESSOR_ALL  },
+{ "st.w",        two (0xdc00, 0x0000),  two (0xfc00, 0x0000),  {R2, D16, R1},  3, PROCESSOR_ALL  },
+{ "stby",        one (0x6801),          one (0xfc01),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "stsr",        one (0x7400),          one (0xfc00),          {SR, R2},       0, PROCESSOR_ALL  },
+{ "sub",         one (0x0800),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "subf.s",      two (0xf800, 0x1400),  two (0xfc00, 0xfc00),  {R1, R2},       0, PROCESSOR_ALL  },
+
+{ "trap",        one (0x6000),          one (0xfc00),          {I5U},          0, PROCESSOR_ALL  },
+{ "trnc.sw",     two (0xf800, 0x2c00),  two (0xfc00, 0xfc00),  {R1, R2},       0, PROCESSOR_ALL  },
+
+{ "xb",          two (0xf800, 0x2000),  two (0xfc00, 0xfc00),  {R2},           0, PROCESSOR_VBOY },
+{ "xh",          two (0xf800, 0x2400),  two (0xfc00, 0xfc00),  {R2},           0, PROCESSOR_VBOY },
+{ "xor",         one (0x3800),          one (0xfc00),          {R1, R2},       0, PROCESSOR_ALL  },
+{ "xori",        two (0xb800, 0x0000),  two (0xfc00, 0x0000),  {I16U, R1, R2}, 0, PROCESSOR_ALL  },
+
+{ "sch0bsd",     one (0x7c01),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "sch0bsu",     one (0x7c00),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "sch1bsd",     one (0x7c03),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "sch1bsu",     one (0x7c02),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "movbsu",      one (0x7c0b),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "notbsu",      one (0x7c0f),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "andbsu",      one (0x7c09),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "andnbsu",     one (0x7c0d),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "orbsu",       one (0x7c08),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "ornbsu",      one (0x7c0c),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "xorbsu",      one (0x7c0a),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+{ "xornbsu",     one (0x7c0e),          one (0xfc1f),          {UNUSED},       0, PROCESSOR_ALL  },
+
+{ 0, 0, 0, {0}, 0, 0 },
+
+} ;
+
+const int v810_num_opcodes =
+  sizeof (v810_opcodes) / sizeof (v810_opcodes[0]);
